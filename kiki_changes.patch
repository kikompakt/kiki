From 885e6d953ac4f971e42edb0da46090fdd129bc2b Mon Sep 17 00:00:00 2001
From: kikompakt <145852663+kikompakt@users.noreply.github.com>
Date: Wed, 30 Jul 2025 12:43:40 +0200
Subject: [PATCH] =?UTF-8?q?=E2=9C=A8=20Simplified=20Kiki=20Chat=20for=20Ra?=
 =?UTF-8?q?ilway=20deployment?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

üöÄ Major simplification and Railway optimization:

‚úÖ New simplified system:
- app_simplified.py: Streamlined Flask app with Railway support
- simple_orchestrator.py: Direct OpenAI Assistant integration
- chat_simple.html: Clean, responsive chat interface

ü§ñ OpenAI Assistants configured:
- Supervisor: asst_19FlW2QtTAIb7Z96f3ukfSre (gpt-4.1-nano)
- Der Autor: asst_UCpHRYdDK2uPsb7no8Zw5Z0p (gpt-4.1-nano)
- Der P√§dagoge: asst_tmj7Nz75MSwjPSrBf4KV2EIt (gpt-4.1-nano)
- Der Pr√ºfer: asst_qH5a6MsVByLHP2ZLQ8gT8jg0 (gpt-4.1-nano)

‚ö° Railway deployment ready:
- railway.json: Optimized configuration
- Procfile: Gunicorn + Gevent setup
- PostgreSQL/SQLite compatibility
- Environment variables support

üìö Documentation:
- DEPLOYMENT_CHECKLIST.md: Complete deployment guide
- README_simplified.md: Setup instructions
- init_assistants.py: Database initialization

üîÑ 3-step workflow as specified:
1. create_content (topic, instructions, content_type)
2. optimize_didactics (content)
3. critically_review (content, review_type)

‚ú® Features maintained:
- SocketIO real-time chat
- File upload with RAG system
- Quality assessment
- User authentication
- Knowledge management

Ready for Railway deployment! üéØ
---
 DEPLOYMENT_CHECKLIST.md     |  132 ++++
 Procfile                    |    2 +-
 Procfile_simplified         |    1 +
 README_simplified.md        |  123 +++
 app.py                      |   12 +-
 app_railway.py              | 1485 -----------------------------------
 app_simplified.py           |  435 ++++++++++
 init_assistants.py          |   49 ++
 railway.json                |    7 +
 requirements.txt            |    9 +-
 requirements_simplified.txt |   25 +
 simple_orchestrator.py      |  586 ++++++++++++++
 start.py                    |   60 ++
 templates/chat_simple.html  |  319 ++++++++
 14 files changed, 1746 insertions(+), 1499 deletions(-)
 create mode 100644 DEPLOYMENT_CHECKLIST.md
 create mode 100644 Procfile_simplified
 create mode 100644 README_simplified.md
 delete mode 100644 app_railway.py
 create mode 100644 app_simplified.py
 create mode 100644 init_assistants.py
 create mode 100644 railway.json
 create mode 100644 requirements_simplified.txt
 create mode 100644 simple_orchestrator.py
 create mode 100644 start.py
 create mode 100644 templates/chat_simple.html

diff --git a/DEPLOYMENT_CHECKLIST.md b/DEPLOYMENT_CHECKLIST.md
new file mode 100644
index 0000000..3d4497e
--- /dev/null
+++ b/DEPLOYMENT_CHECKLIST.md
@@ -0,0 +1,132 @@
+# üöÄ Railway Deployment Checklist f√ºr Kiki Chat
+
+## ‚úÖ Vorbereitung (Lokal)
+
+- [x] Vereinfachte App erstellt (`app_simplified.py`)
+- [x] Vereinfachter Orchestrator implementiert (`simple_orchestrator.py`)
+- [x] Railway-Konfiguration erstellt (`railway.json`, `Procfile`)
+- [x] Abh√§ngigkeiten aktualisiert (`requirements.txt`)
+- [x] Einfaches Chat-Interface (`templates/chat_simple.html`)
+- [x] Datenbank-Initialisierung (`init_assistants.py`)
+- [x] README f√ºr Deployment (`README_simplified.md`)
+
+## üîß OpenAI Assistenten (Konfiguriert)
+
+- [x] **Supervisor**: `asst_19FlW2QtTAIb7Z96f3ukfSre` (gpt-4.1-nano)
+- [x] **Der Autor**: `asst_UCpHRYdDK2uPsb7no8Zw5Z0p` (gpt-4.1-nano)
+- [x] **Der P√§dagoge**: `asst_tmj7Nz75MSwjPSrBf4KV2EIt` (gpt-4.1-nano)
+- [x] **Der Pr√ºfer**: `asst_qH5a6MsVByLHP2ZLQ8gT8jg0` (gpt-4.1-nano)
+
+## üìã Railway Deployment Schritte
+
+### 1. Repository vorbereiten
+```bash
+git add .
+git commit -m "Simplified Kiki Chat for Railway deployment"
+git push origin main
+```
+
+### 2. Railway Setup
+1. **Railway Account**: https://railway.app
+2. **Neues Projekt**: "Deploy from GitHub Repo"
+3. **Repository ausw√§hlen**: `@https://github.com/kikompakt/kiki`
+
+### 3. Environment Variables setzen
+In Railway Dashboard ‚Üí Settings ‚Üí Environment:
+```
+OPENAI_API_KEY=your_openai_api_key_here
+SECRET_KEY=kiki-chat-production-secret-key-2024
+```
+
+### 4. PostgreSQL hinzuf√ºgen
+1. **Add Service** ‚Üí **Database** ‚Üí **PostgreSQL**
+2. Railway setzt automatisch `DATABASE_URL`
+
+### 5. Deployment √ºberpr√ºfen
+- Railway erkennt automatisch `railway.json` und `Procfile`
+- Start Command: `gunicorn --worker-class=gevent --workers=1 --bind=0.0.0.0:$PORT app_simplified:app`
+- Build erfolgreich
+- Service l√§uft unter generierter Railway-URL
+
+## üß™ Testing Checklist
+
+### Lokal testen (vor Deployment)
+```bash
+# Environment setzen
+export OPENAI_API_KEY=your_key_here
+export SECRET_KEY=test-secret-key
+export DATABASE_URL=sqlite:///test.db
+
+# App starten
+python app_simplified.py
+```
+
+### Nach Railway Deployment
+- [ ] App erreichbar unter Railway-URL
+- [ ] Login funktioniert (admin/admin123, demo/demo123)
+- [ ] Chat-Interface l√§dt
+- [ ] Nachrichten k√∂nnen gesendet werden
+- [ ] OpenAI Assistenten antworten
+- [ ] File-Upload funktioniert (optional)
+
+## üîç Troubleshooting
+
+### H√§ufige Probleme
+1. **OpenAI API Key fehlt**
+   - Environment Variable `OPENAI_API_KEY` in Railway pr√ºfen
+
+2. **Assistant nicht gefunden**
+   - Assistant IDs in Railway Logs √ºberpr√ºfen
+   - OpenAI API Limits/Permissions pr√ºfen
+
+3. **Database Connection Failed**
+   - PostgreSQL Service l√§uft
+   - `DATABASE_URL` automatisch gesetzt
+
+4. **Import Errors**
+   - `requirements.txt` vollst√§ndig
+   - Python Version kompatibel
+
+### Railway Logs ansehen
+```bash
+railway logs --follow
+```
+
+## üìÅ Wichtige Dateien f√ºr Deployment
+
+```
+kiki-chat/
+‚îú‚îÄ‚îÄ app_simplified.py          # üîÑ Hauptanwendung (VERWENDEN)
+‚îú‚îÄ‚îÄ simple_orchestrator.py     # üîÑ KI-Orchestrierung (VERWENDEN)
+‚îú‚îÄ‚îÄ knowledge_manager.py       # ‚úÖ RAG-System (optional)
+‚îú‚îÄ‚îÄ quality_assessment.py      # ‚úÖ Qualit√§tsbewertung (optional)
+‚îú‚îÄ‚îÄ templates/
+‚îÇ   ‚îî‚îÄ‚îÄ chat_simple.html       # üîÑ Chat-Interface (VERWENDEN)
+‚îú‚îÄ‚îÄ requirements.txt            # üîÑ Abh√§ngigkeiten (AKTUALISIERT)
+‚îú‚îÄ‚îÄ railway.json               # ‚ú® Railway-Konfiguration (NEU)
+‚îú‚îÄ‚îÄ Procfile                    # üîÑ Start-Command (AKTUALISIERT)
+‚îú‚îÄ‚îÄ init_assistants.py         # ‚ú® DB-Initialisierung (NEU)
+‚îî‚îÄ‚îÄ README_simplified.md       # ‚ú® Deployment-Anleitung (NEU)
+```
+
+## ‚úÖ Erfolgskriterien
+
+- ‚úÖ Vereinfachtes System (90% weniger Code-Komplexit√§t)
+- ‚úÖ Direkte OpenAI Assistant Integration
+- ‚úÖ Railway-kompatible Konfiguration
+- ‚úÖ PostgreSQL Support
+- ‚úÖ Funktionale 3-Schritt-Kurserstellung
+- ‚úÖ Einfaches, stabiles Chat-Interface
+- ‚úÖ File-Upload mit RAG-System (optional)
+
+## üéØ N√§chste Schritte
+
+Nach erfolgreichem Deployment:
+1. **URL testen**: Alle Funktionen durchgehen
+2. **Performance √ºberwachen**: Railway Metrics
+3. **Logs √ºberwachen**: Fehler und Warnungen
+4. **OpenAI Usage**: API-Kosten im Blick behalten
+
+---
+
+**üöÄ Das System ist jetzt bereit f√ºr Railway Deployment!**
\ No newline at end of file
diff --git a/Procfile b/Procfile
index 51c3128..e139737 100644
--- a/Procfile
+++ b/Procfile
@@ -1 +1 @@
-web: gunicorn --worker-class=gevent --workers=1 --timeout=300 --keep-alive=120 --max-requests=500 --bind=0.0.0.0:8080 app_railway:app 
\ No newline at end of file
+web: gunicorn --worker-class=gevent --workers=1 --timeout=300 --keep-alive=120 --max-requests=500 --bind=0.0.0.0:$PORT app_simplified:app 
\ No newline at end of file
diff --git a/Procfile_simplified b/Procfile_simplified
new file mode 100644
index 0000000..60038f8
--- /dev/null
+++ b/Procfile_simplified
@@ -0,0 +1 @@
+web: gunicorn --worker-class gevent --worker-connections 1000 --workers 1 --bind 0.0.0.0:$PORT app_simplified:app
\ No newline at end of file
diff --git a/README_simplified.md b/README_simplified.md
new file mode 100644
index 0000000..88891b7
--- /dev/null
+++ b/README_simplified.md
@@ -0,0 +1,123 @@
+# Kiki Chat - Vereinfachtes KI-Kursstudio
+
+Vereinfachtes System f√ºr automatisierte Kurserstellung mit OpenAI Assistenten.
+
+## üöÄ Railway Deployment
+
+### 1. Vorbereitung
+
+1. **Repository erstellen**:
+   ```bash
+   git init
+   git add .
+   git commit -m "Initial commit"
+   git push origin main
+   ```
+
+2. **Railway Account**: Registrierung auf [Railway.app](https://railway.app)
+
+### 2. Environment Variables (Railway)
+
+Setzen Sie folgende Umgebungsvariablen in Railway:
+
+```
+OPENAI_API_KEY=your_openai_api_key_here
+SECRET_KEY=your_secret_key_here
+DATABASE_URL=(wird automatisch von Railway gesetzt)
+PORT=(wird automatisch von Railway gesetzt)
+```
+
+### 3. Deployment
+
+1. **Railway Projekt erstellen**:
+   - Mit GitHub Repository verbinden
+   - Railway erkennt automatisch die `railway.json`
+
+2. **PostgreSQL hinzuf√ºgen**:
+   - In Railway Dashboard: "Add Service" ‚Üí "Database" ‚Üí "PostgreSQL"
+   - DATABASE_URL wird automatisch gesetzt
+
+3. **Deploy**:
+   - Railway startet automatisch den Deployment-Prozess
+   - Start Command: `gunicorn --worker-class gevent --worker-connections 1000 --workers 1 --bind 0.0.0.0:$PORT app_simplified:app`
+
+## üîß Lokale Entwicklung
+
+```bash
+# Virtual Environment
+python -m venv venv
+source venv/bin/activate  # Linux/Mac
+# oder
+venv\Scripts\activate     # Windows
+
+# Dependencies installieren
+pip install -r requirements_simplified.txt
+
+# Environment Variables (.env Datei)
+OPENAI_API_KEY=your_key_here
+SECRET_KEY=dev-secret-key
+DATABASE_URL=sqlite:///kiki_chat.db
+
+# Anwendung starten
+python app_simplified.py
+```
+
+## ü§ñ OpenAI Assistenten
+
+Das System verwendet folgende vorkonfigurierte Assistenten:
+
+- **Supervisor** (`asst_19FlW2QtTAIb7Z96f3ukfSre`) - Hauptsteuerung
+- **Der Autor** (`asst_UCpHRYdDK2uPsb7no8Zw5Z0p`) - Content-Erstellung
+- **Der P√§dagoge** (`asst_tmj7Nz75MSwjPSrBf4KV2EIt`) - Didaktische Optimierung
+- **Der Pr√ºfer** (`asst_qH5a6MsVByLHP2ZLQ8gT8jg0`) - Qualit√§tspr√ºfung
+
+Alle Assistenten verwenden das Modell `gpt-4.1-nano`.
+
+## üìÅ Vereinfachte Struktur
+
+```
+kiki-chat/
+‚îú‚îÄ‚îÄ app_simplified.py          # Hauptanwendung
+‚îú‚îÄ‚îÄ simple_orchestrator.py     # KI-Orchestrierung
+‚îú‚îÄ‚îÄ knowledge_manager.py       # RAG-System (optional)
+‚îú‚îÄ‚îÄ quality_assessment.py      # Qualit√§tsbewertung (optional)
+‚îú‚îÄ‚îÄ templates/
+‚îÇ   ‚îî‚îÄ‚îÄ chat_simple.html       # Chat-Interface
+‚îú‚îÄ‚îÄ requirements_simplified.txt
+‚îú‚îÄ‚îÄ railway.json
+‚îú‚îÄ‚îÄ Procfile_simplified
+‚îî‚îÄ‚îÄ start.py                   # Initialisierung
+```
+
+## üîÑ Workflow
+
+1. **User-Input**: Benutzer beschreibt Kursidee
+2. **Supervisor**: Erkennt Intent und startet 3-Schritt-Workflow
+3. **Content Creator**: Erstellt Rohinhalt
+4. **Didactic Expert**: Optimiert didaktisch
+5. **Quality Checker**: Pr√ºft und bewertet
+6. **Output**: Fertiger Kurs wird angezeigt
+
+## üìù Standard-Benutzer
+
+- **Admin**: `admin` / `admin123`
+- **Demo**: `demo` / `demo123`
+
+## üêõ Troubleshooting
+
+**Railway Logs ansehen**:
+```bash
+railway logs
+```
+
+**H√§ufige Probleme**:
+- OpenAI API Key fehlt oder ung√ºltig
+- Assistant IDs nicht gefunden
+- Datenbankverbindung fehlgeschlagen
+
+## üìû Support
+
+Bei Problemen:
+1. Railway Logs pr√ºfen
+2. Environment Variables kontrollieren
+3. OpenAI Assistant Status √ºberpr√ºfen
\ No newline at end of file
diff --git a/app.py b/app.py
index 0a54886..61f84d5 100644
--- a/app.py
+++ b/app.py
@@ -1,14 +1,12 @@
 """
-Intelligentes KI-Kursstudio - Hauptanwendung
-MVP Version: Basis Flask-App mit Login-System und Chat-Interface Foundation
+Kiki Chat - Vereinfachtes KI-Kursstudio
+Optimiert f√ºr Railway Deployment
 
 Architecture:
 - Flask + SocketIO f√ºr Echtzeit-Kommunikation
-- SQLite f√ºr User-Management
-- Modulare Struktur f√ºr Skalierbarkeit
-- Integration mit bestehenden Agenten-Logiken
-- MEMORY MANAGEMENT: TTL-basierte Orchestrator-Cleanup
-- TYPE SAFETY: Umfassende Type-Hints f√ºr Production-Readiness
+- SQLite/PostgreSQL f√ºr Datenbank (Railway kompatibel)
+- Vereinfachte Agent-Orchestrierung
+- Direkte OpenAI Assistant Integration
 """
 
 import os
diff --git a/app_railway.py b/app_railway.py
deleted file mode 100644
index 9c640a3..0000000
--- a/app_railway.py
+++ /dev/null
@@ -1,1485 +0,0 @@
-"""
-Intelligentes KI-Kursstudio - Railway Production Version
-Optimiert f√ºr PostgreSQL-Deployment mit SQLAlchemy
-"""
-
-import os
-import json
-import logging
-from datetime import datetime, timedelta
-from flask import Flask, render_template, request, jsonify, redirect, url_for, session, flash
-from flask_socketio import SocketIO, emit, join_room, leave_room
-from werkzeug.security import generate_password_hash, check_password_hash
-from chat_orchestrator import DynamicChatOrchestrator
-from apscheduler.schedulers.background import BackgroundScheduler
-from apscheduler.triggers.interval import IntervalTrigger
-from dotenv import load_dotenv
-from models import db, User, Project, Assistant, Workflow, WorkflowStep, ChatSession, ChatMessage, Course, CourseSection
-import time
-import gc
-
-# Load environment variables
-load_dotenv()
-
-app = Flask(__name__)
-app.config['SECRET_KEY'] = os.environ.get('FLASK_SECRET_KEY', 'dev-secret-key-change-in-production')
-
-# Database Configuration - Support both SQLite (local) and PostgreSQL (Railway)
-database_url = os.environ.get('DATABASE_URL')
-if database_url:
-    # Railway PostgreSQL
-    if database_url.startswith('postgres://'):
-        database_url = database_url.replace('postgres://', 'postgresql://', 1)
-    app.config['SQLALCHEMY_DATABASE_URI'] = database_url
-else:
-    # Local SQLite fallback
-    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///kursstudio.db'
-
-app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
-
-# Initialize extensions
-db.init_app(app)
-
-# Configure logging - optimized for Railway (MUST BE BEFORE SOCKETIO!)
-logging.basicConfig(
-    level=logging.INFO,
-    format='%(levelname)s:%(name)s:%(message)s',
-    handlers=[logging.StreamHandler()]
-)
-logger = logging.getLogger(__name__)
-
-# Reduce verbose logging for certain modules
-logging.getLogger('urllib3').setLevel(logging.WARNING)
-logging.getLogger('werkzeug').setLevel(logging.WARNING)
-
-# Optimized SocketIO for Railway with gevent fallback
-try:
-    import gevent
-    socketio = SocketIO(app, cors_allowed_origins="*", async_mode='gevent', 
-                       ping_timeout=60, ping_interval=25, 
-                       max_http_buffer_size=1024*1024)  # 1MB limit
-    logger.info("SocketIO initialized with gevent")
-except (ImportError, ModuleNotFoundError):
-    socketio = SocketIO(app, cors_allowed_origins="*", 
-                       ping_timeout=60, ping_interval=25, 
-                       max_http_buffer_size=1024*1024)  # 1MB limit
-    logger.warning("SocketIO initialized without gevent - using threading")
-
-# Global orchestrator storage with cleanup
-orchestrators = {}
-
-# Memory management
-MAX_ORCHESTRATORS = 50  # Limit concurrent orchestrators
-ORCHESTRATOR_TIMEOUT = 1800  # 30 minutes timeout
-
-# Database initialization and default data
-def init_database():
-    """Initialize database with tables and default data"""
-    with app.app_context():
-        try:
-            # Test database connection first
-            logger.info(f"Connecting to database: {app.config['SQLALCHEMY_DATABASE_URI'][:50]}...")
-            
-            # Test connection - SQLAlchemy 2.0 compatible
-            with db.engine.connect() as conn:
-                conn.execute(db.text('SELECT 1'))
-                conn.commit()
-            logger.info("Database connection successful")
-            
-            # Create tables
-            db.create_all()
-            logger.info("Database tables created")
-            
-            # Initialize default data
-            init_default_users()
-            init_default_assistants()
-            init_default_workflows()
-            
-            logger.info("Database initialized successfully")
-            return True
-            
-        except Exception as e:
-            logger.error(f"Database initialization failed: {e}")
-            logger.error(f"Database URL: {app.config['SQLALCHEMY_DATABASE_URI']}")
-            
-            # Fallback to SQLite if PostgreSQL fails
-            if 'postgresql' in app.config['SQLALCHEMY_DATABASE_URI']:
-                logger.warning("PostgreSQL connection failed, falling back to SQLite")
-                app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///kursstudio.db'
-                try:
-                    db.create_all()
-                    init_default_users()
-                    init_default_assistants()
-                    init_default_workflows()
-                    logger.info("Fallback to SQLite successful")
-                    return True
-                except Exception as fallback_error:
-                    logger.error(f"SQLite fallback also failed: {fallback_error}")
-                    return False
-            
-            return False
-
-def init_default_users():
-    """Create default users if they don't exist"""
-    if not User.query.filter_by(username='admin').first():
-        admin_password_hash = generate_password_hash('admin123')
-        admin_user = User(username='admin', password_hash=admin_password_hash, role='admin')
-        db.session.add(admin_user)
-        
-    if not User.query.filter_by(username='user').first():
-        user_password_hash = generate_password_hash('user123')
-        regular_user = User(username='user', password_hash=user_password_hash, role='user')
-        db.session.add(regular_user)
-        
-    db.session.commit()
-    logger.info("Default users created")
-
-def init_default_assistants():
-    """Create default assistants if they don't exist"""
-    default_assistants = [
-        {
-            'name': 'Supervisor',
-            'assistant_id': 'asst_19FlW2QtTAIb7Z96f3ukfSre',
-            'role': 'supervisor',
-            'description': 'Freundlicher und hochkompetenter Direktor des KI-Kursstudios',
-            'instructions': '''Du bist ein freundlicher und hilfreicher Assistent und der Orchestrator f√ºr das KI-Kursstudio.
-
-**WICHTIGSTE REGEL: Wenn der Nutzer eine einfache Frage stellt oder eine Begr√ºssung wie 'Hallo' schickt, antworte immer direkt, h√∂flich und konversationell. Daf√ºr brauchst du kein Werkzeug.**
-
-F√ºr komplexe Aufgaben wie die Erstellung eines Kurses, nutze deinen erweiterten Workflow.
-
-Der NEUE 7-Schritte-Workflow:
-
-1. **Outline-Erstellung**: Rufe den Content Creator auf mit content_type="outline", um ein detailliertes Inhaltsverzeichnis zu erstellen (Kapitel + Lernziele + grobe Beschreibung).
-
-2. **Outline-Qualit√§tspr√ºfung**: Lasse den Quality Checker das Outline mit review_type="outline" bewerten und pr√ºfen.
-
-3. **Outline-Freigabe**: Verwende request_outline_approval, um dem Nutzer das gepr√ºfte Inhaltsverzeichnis zu zeigen und nach seiner Freigabe zu fragen.
-
-4. **Volltext-Erstellung**: Rufe den Content Creator erneut auf mit content_type="full_content", um basierend auf dem genehmigten Outline den vollst√§ndigen Kursinhalt zu erstellen.
-
-5. **Didaktische Optimierung**: √úbergebe den Volltext an den Didactic Expert mit optimize_didactics.
-
-6. **Finale Qualit√§tspr√ºfung**: Lasse den Quality Checker den vollst√§ndigen Inhalt mit review_type="full_content" bewerten.
-
-7. **Finale Freigabe**: Verwende request_user_feedback f√ºr die finale Freigabe.''',
-            'order_index': 1
-        }
-    ]
-    
-    for assistant_data in default_assistants:
-        if not Assistant.query.filter_by(assistant_id=assistant_data['assistant_id']).first():
-            assistant = Assistant(**assistant_data)
-            db.session.add(assistant)
-    
-    # Update existing assistants with new timeout settings
-    existing_assistants = Assistant.query.all()
-    for assistant in existing_assistants:
-        current_timeout = assistant.timeout_seconds
-        logger.info(f"Assistant {assistant.name}: current timeout = {current_timeout}")
-        
-        # Update any timeout that's not 300s (handles NULL, 180, or other values)
-        if current_timeout != 300:
-            old_timeout = current_timeout
-            assistant.timeout_seconds = 300
-            logger.info(f"‚úÖ Updated timeout for assistant {assistant.name}: {old_timeout}s ‚Üí 300s")
-        else:
-            logger.info(f"Assistant {assistant.name} already has 300s timeout")
-    
-    db.session.commit()
-    logger.info("Default assistants initialized")
-
-def init_default_workflows():
-    """Create default workflows if they don't exist"""
-    existing_workflow = Workflow.query.filter_by(name='Standard-Kurs-Erstellung').first()
-    
-    if not existing_workflow:
-        # Create new workflow
-        workflow = Workflow(
-            name='Standard-Kurs-Erstellung',
-            description='Professioneller 7-Schritt-Workflow f√ºr hochwertige Online-Kurse',
-            workflow_type='sequential',  # Fixed: Use frontend-compatible type
-            is_active=True,
-            is_default=True
-        )
-        db.session.add(workflow)
-        db.session.flush()  # Get the workflow ID
-        logger.info("Creating new default workflow")
-    else:
-        # Update existing workflow if needed
-        workflow = existing_workflow
-        if workflow.workflow_type == 'course_creation':
-            workflow.workflow_type = 'sequential'
-            logger.info("Updated workflow type from course_creation to sequential")
-        
-        # FORCE RECREATION: Delete existing steps and recreate with correct steps
-        existing_steps_count = WorkflowStep.query.filter_by(workflow_id=workflow.id).count()
-        if existing_steps_count > 0:
-            logger.info(f"FORCE UPDATE: Deleting {existing_steps_count} existing steps to recreate proper workflow")
-            WorkflowStep.query.filter_by(workflow_id=workflow.id).delete()
-        else:
-            logger.info("No existing steps found, creating new ones")
-    
-    # Create default workflow steps (ALWAYS CREATE THESE)
-    default_steps = [
-        {
-            'step_name': 'Outline-Erstellung',
-            'agent_role': 'supervisor',
-            'order_index': 1,
-            'input_source': 'user_input',
-            'output_target': 'raw_content'
-        },
-        {
-            'step_name': 'Outline-Qualit√§tspr√ºfung', 
-            'agent_role': 'supervisor',
-            'order_index': 2,
-            'input_source': 'raw_content',
-            'output_target': 'optimized_content'
-        },
-        {
-            'step_name': 'Volltext-Erstellung',
-            'agent_role': 'supervisor', 
-            'order_index': 3,
-            'input_source': 'optimized_content',
-            'output_target': 'raw_content'
-        },
-        {
-            'step_name': 'Didaktische Optimierung',
-            'agent_role': 'supervisor',
-            'order_index': 4, 
-            'input_source': 'raw_content',
-            'output_target': 'optimized_content'
-        },
-        {
-            'step_name': 'Finale Qualit√§tspr√ºfung',
-            'agent_role': 'supervisor',
-            'order_index': 5,
-            'input_source': 'optimized_content', 
-            'output_target': 'final_content'
-        },
-        {
-            'step_name': 'Finale Freigabe',
-            'agent_role': 'supervisor',
-            'order_index': 6,
-            'input_source': 'final_content',
-            'output_target': 'approved_content'
-        }
-    ]
-    
-    logger.info(f"Creating {len(default_steps)} workflow steps")
-    
-    for i, step_data in enumerate(default_steps):
-        step = WorkflowStep(
-            workflow_id=workflow.id,
-            step_name=step_data['step_name'],
-            agent_role=step_data['agent_role'],
-            order_index=step_data['order_index'],
-            is_enabled=True,
-            is_parallel=False,
-            retry_attempts=3,
-            timeout_seconds=300,  # Use the corrected timeout
-            execution_condition=None,
-            input_source=step_data['input_source'],
-            output_target=step_data['output_target']
-        )
-        db.session.add(step)
-        logger.info(f"Added step {i+1}: {step_data['step_name']}")
-    
-    db.session.commit()
-    
-    # Verify creation
-    final_steps_count = WorkflowStep.query.filter_by(workflow_id=workflow.id).count()
-    logger.info(f"‚úÖ WORKFLOW STEPS VERIFICATION: {final_steps_count} steps created successfully")
-
-def cleanup_orchestrators():
-    """Clean up old orchestrators to prevent memory leaks"""
-    global orchestrators
-    
-    current_time = time.time()
-    to_remove = []
-    
-    # Find orchestrators to remove
-    for user_id, orchestrator_data in orchestrators.items():
-        if isinstance(orchestrator_data, dict):
-            last_activity = orchestrator_data.get('last_activity', 0)
-        else:
-            # Legacy orchestrator object - mark for removal
-            last_activity = 0
-            
-        if current_time - last_activity > ORCHESTRATOR_TIMEOUT:
-            to_remove.append(user_id)
-    
-    # Remove old orchestrators
-    for user_id in to_remove:
-        if user_id in orchestrators:
-            try:
-                del orchestrators[user_id]
-                logger.info(f"Cleaned up orchestrator for user {user_id}")
-            except Exception as e:
-                logger.error(f"Error cleaning orchestrator for user {user_id}: {e}")
-    
-    # Force garbage collection if too many orchestrators
-    if len(orchestrators) > MAX_ORCHESTRATORS:
-        # Keep only the most recent ones
-        sorted_orchestrators = sorted(
-            orchestrators.items(),
-            key=lambda x: x[1].get('last_activity', 0) if isinstance(x[1], dict) else 0,
-            reverse=True
-        )
-        
-        # Keep only the newest MAX_ORCHESTRATORS
-        new_orchestrators = dict(sorted_orchestrators[:MAX_ORCHESTRATORS])
-        orchestrators.clear()
-        orchestrators.update(new_orchestrators)
-        
-        # Force garbage collection
-        gc.collect()
-        logger.info(f"Forced cleanup: kept {len(orchestrators)} orchestrators, triggered GC")
-    
-    logger.info(f"Memory cleanup: {len(orchestrators)} active orchestrators")
-
-# Authentication decorator
-def require_auth(f):
-    """Decorator to require authentication"""
-    def decorated_function(*args, **kwargs):
-        if 'user_id' not in session:
-            return redirect(url_for('login'))
-        return f(*args, **kwargs)
-    decorated_function.__name__ = f.__name__
-    return decorated_function
-
-def require_admin(f):
-    """Decorator to require admin role"""
-    def decorated_function(*args, **kwargs):
-        if 'user_id' not in session:
-            return redirect(url_for('login'))
-        if session.get('role') != 'admin':
-            flash('Admin access required', 'error')
-            return redirect(url_for('dashboard'))
-        return f(*args, **kwargs)
-    decorated_function.__name__ = f.__name__
-    return decorated_function
-
-# Routes
-@app.route('/')
-def index():
-    """Homepage - redirect based on auth status"""
-    if 'user_id' in session:
-        return redirect(url_for('dashboard'))
-    return redirect(url_for('login'))
-
-@app.route('/login', methods=['GET', 'POST'])
-def login():
-    """User login"""
-    if request.method == 'POST':
-        username = request.form['username']
-        password = request.form['password']
-        
-        user = User.query.filter_by(username=username).first()
-        
-        if user and check_password_hash(user.password_hash, password):
-            session['user_id'] = user.id
-            session['username'] = user.username
-            session['role'] = user.role
-            
-            # Update last login
-            user.last_login = datetime.utcnow()
-            db.session.commit()
-            
-            flash('Login successful!', 'success')
-            return redirect(url_for('dashboard'))
-        else:
-            flash('Invalid username or password', 'error')
-    
-    return render_template('login.html')
-
-@app.route('/logout')
-def logout():
-    """User logout"""
-    session.clear()
-    flash('You have been logged out.', 'info')
-    return redirect(url_for('login'))
-
-@app.route('/dashboard')
-@require_auth
-def dashboard():
-    """User dashboard"""
-    user = User.query.get(session['user_id'])
-    return render_template('dashboard.html', user=user)
-
-@app.route('/new_project', methods=['POST'])
-@require_auth
-def new_project():
-    """Create a new project"""
-    try:
-        title = request.form.get('title', '').strip()
-        description = request.form.get('description', '').strip()
-        
-        if not title:
-            flash('Projekt-Titel ist erforderlich', 'error')
-            return redirect(url_for('dashboard'))
-            
-        # Create new project
-        project = Project(
-            title=title,
-            description=description if description else None,
-            user_id=session['user_id']
-        )
-        
-        db.session.add(project)
-        db.session.commit()
-        
-        flash(f'Projekt "{title}" erfolgreich erstellt!', 'success')
-        logger.info(f"New project created: {title} by user {session['user_id']}")
-        
-    except Exception as e:
-        logger.error(f"Error creating project: {e}")
-        flash('Fehler beim Erstellen des Projekts', 'error')
-        db.session.rollback()
-    
-    return redirect(url_for('dashboard'))
-
-@app.route('/chat')
-@require_auth
-def chat():
-    """Chat interface"""
-    return render_template('chat.html')
-
-@app.route('/admin')
-@require_admin
-def admin_panel():
-    """Admin panel"""
-    return render_template('admin.html')
-
-@app.route('/admin/assistants')
-@require_admin
-def admin_assistants():
-    """Assistant management"""
-    assistants = Assistant.query.order_by(Assistant.order_index.asc()).all()
-    return render_template('admin_assistants.html', assistants=assistants)
-
-@app.route('/admin/workflows')
-@require_admin
-def admin_workflows():
-    """Workflow management"""
-    try:
-        # Simplified query - get workflows first, then count steps separately
-        workflows = Workflow.query.all()
-        
-        # Add step_count attribute to each workflow
-        for workflow in workflows:
-            step_count = WorkflowStep.query.filter_by(workflow_id=workflow.id).count()
-            workflow.step_count = step_count
-        
-        assistants = Assistant.query.filter_by(is_active=True).all()
-        
-        logger.info(f"Loaded {len(workflows)} workflows and {len(assistants)} assistants for admin")
-        
-        return render_template('admin_workflows.html', workflows=workflows, assistants=assistants)
-        
-    except Exception as e:
-        logger.error(f"Error loading workflows: {e}")
-        # Return empty data to prevent template errors
-        return render_template('admin_workflows.html', workflows=[], assistants=[])
-
-@app.route('/admin/workflows/help')
-@require_admin
-def admin_workflows_help():
-    """Admin workflow help page"""
-    return render_template('admin_workflows_help.html')
-
-@app.route('/courses')
-def courses():
-    """Display user's saved courses"""
-    if 'user_id' not in session:
-        return redirect(url_for('login'))
-    
-    try:
-        user_id = session.get('user_id')
-        courses = Course.query.filter_by(user_id=user_id).order_by(Course.created_at.desc()).all()
-        
-        # Add section counts to courses
-        for course in courses:
-            course.sections_count = CourseSection.query.filter_by(course_id=course.id).count()
-        
-        return render_template('courses.html', courses=courses)
-    except Exception as e:
-        logger.error(f"Error loading courses page: {e}")
-        return redirect(url_for('dashboard'))
-
-@app.route('/courses/<int:course_id>')
-def view_course(course_id):
-    """Display a specific course"""
-    if 'user_id' not in session:
-        return redirect(url_for('login'))
-    
-    try:
-        user_id = session.get('user_id')
-        course = Course.query.filter_by(id=course_id, user_id=user_id).first()
-        
-        if not course:
-            flash('Kurs nicht gefunden.', 'error')
-            return redirect(url_for('courses'))
-        
-        # Get course sections
-        sections = CourseSection.query.filter_by(course_id=course.id).order_by(CourseSection.section_order).all()
-        
-        return render_template('course_view.html', course=course, sections=sections)
-    except Exception as e:
-        logger.error(f"Error loading course {course_id}: {e}")
-        return redirect(url_for('courses'))
-
-# Workflow API Routes
-@app.route('/api/workflows', methods=['GET'])
-@require_admin
-def api_get_workflows():
-    """Get all workflows"""
-    workflows = Workflow.query.all()
-    workflow_list = []
-    
-    for workflow in workflows:
-        steps = WorkflowStep.query.filter_by(workflow_id=workflow.id).order_by(WorkflowStep.order_index).all()
-        workflow_data = {
-            'id': workflow.id,
-            'name': workflow.name,
-            'description': workflow.description,
-            'workflow_type': workflow.workflow_type,
-            'is_active': workflow.is_active,
-            'is_default': workflow.is_default,
-            'created_at': workflow.created_at.isoformat() if workflow.created_at else None,
-            'steps': [{
-                'id': step.id,
-                'step_name': step.step_name,
-                'agent_role': step.agent_role,
-                'order_index': step.order_index,
-                'is_enabled': step.is_enabled,
-                'is_parallel': step.is_parallel,
-                'retry_attempts': step.retry_attempts,
-                'timeout_seconds': step.timeout_seconds,
-                'execution_condition': step.execution_condition,
-                'input_source': step.input_source,
-                'output_target': step.output_target
-            } for step in steps]
-        }
-        workflow_list.append(workflow_data)
-    
-    return jsonify(workflow_list)
-
-@app.route('/api/workflows/<int:workflow_id>', methods=['GET'])
-@require_admin
-def api_get_workflow(workflow_id):
-    """Get specific workflow"""
-    workflow = Workflow.query.get_or_404(workflow_id)
-    steps = WorkflowStep.query.filter_by(workflow_id=workflow.id).order_by(WorkflowStep.order_index).all()
-    
-    workflow_data = {
-        'id': workflow.id,
-        'name': workflow.name,
-        'description': workflow.description,
-        'workflow_type': workflow.workflow_type,
-        'is_active': workflow.is_active,
-        'is_default': workflow.is_default,
-        'steps': [{
-            'step_name': step.step_name,
-            'agent_role': step.agent_role,
-            'order_index': step.order_index,
-            'is_enabled': step.is_enabled,
-            'is_parallel': step.is_parallel,
-            'retry_attempts': step.retry_attempts,
-            'timeout_seconds': step.timeout_seconds,
-            'execution_condition': step.execution_condition,
-            'input_source': step.input_source,
-            'output_target': step.output_target
-        } for step in steps]
-    }
-    
-    return jsonify(workflow_data)
-
-@app.route('/api/workflows', methods=['POST'])
-@require_admin  
-def api_create_workflow():
-    """Create new workflow"""
-    try:
-        data = request.get_json()
-        
-        # Create workflow
-        workflow = Workflow(
-            name=data['name'],
-            description=data.get('description'),
-            workflow_type=data.get('workflow_type', 'sequential'),
-            is_active=data.get('is_active', True),
-            is_default=data.get('is_default', False),
-            created_by=session.get('user_id')
-        )
-        
-        db.session.add(workflow)
-        db.session.flush()  # Get the ID
-        
-        # Add steps
-        for step_data in data.get('steps', []):
-            step = WorkflowStep(
-                workflow_id=workflow.id,
-                step_name=step_data['step_name'],
-                agent_role=step_data['agent_role'],
-                order_index=step_data['order_index'],
-                is_enabled=step_data.get('is_enabled', True),
-                is_parallel=step_data.get('is_parallel', False),
-                retry_attempts=step_data.get('retry_attempts', 3),
-                timeout_seconds=step_data.get('timeout_seconds', 180),
-                execution_condition=step_data.get('execution_condition'),
-                input_source=step_data.get('input_source'),
-                output_target=step_data.get('output_target')
-            )
-            db.session.add(step)
-        
-        db.session.commit()
-        logger.info(f"Created workflow: {workflow.name} by user {session.get('user_id')}")
-        
-        return jsonify({'success': True, 'id': workflow.id})
-        
-    except Exception as e:
-        db.session.rollback()
-        logger.error(f"Error creating workflow: {e}")
-        return jsonify({'error': str(e)}), 400
-
-@app.route('/api/workflows/<int:workflow_id>', methods=['PUT'])
-@require_admin
-def api_update_workflow(workflow_id):
-    """Update workflow"""
-    try:
-        workflow = Workflow.query.get_or_404(workflow_id)
-        data = request.get_json()
-        
-        # Update workflow fields
-        workflow.name = data['name']
-        workflow.description = data.get('description')
-        workflow.workflow_type = data.get('workflow_type', 'sequential')
-        workflow.is_active = data.get('is_active', True)
-        workflow.is_default = data.get('is_default', False)
-        workflow.updated_at = datetime.utcnow()
-        
-        # Delete existing steps
-        WorkflowStep.query.filter_by(workflow_id=workflow.id).delete()
-        
-        # Add new steps
-        for step_data in data.get('steps', []):
-            step = WorkflowStep(
-                workflow_id=workflow.id,
-                step_name=step_data['step_name'],
-                agent_role=step_data['agent_role'],
-                order_index=step_data['order_index'],
-                is_enabled=step_data.get('is_enabled', True),
-                is_parallel=step_data.get('is_parallel', False),
-                retry_attempts=step_data.get('retry_attempts', 3),
-                timeout_seconds=step_data.get('timeout_seconds', 180),
-                execution_condition=step_data.get('execution_condition'),
-                input_source=step_data.get('input_source'),
-                output_target=step_data.get('output_target')
-            )
-            db.session.add(step)
-        
-        db.session.commit()
-        logger.info(f"Updated workflow: {workflow.name}")
-        
-        return jsonify({'success': True})
-        
-    except Exception as e:
-        db.session.rollback()
-        logger.error(f"Error updating workflow: {e}")
-        return jsonify({'error': str(e)}), 400
-
-@app.route('/api/workflows/<int:workflow_id>', methods=['DELETE'])
-@require_admin
-def api_delete_workflow(workflow_id):
-    """Delete workflow"""
-    try:
-        workflow = Workflow.query.get_or_404(workflow_id)
-        
-        # Don't allow deleting default workflows
-        if workflow.is_default:
-            return jsonify({'error': 'Standard-Workflows k√∂nnen nicht gel√∂scht werden'}), 400
-        
-        # Delete steps first
-        WorkflowStep.query.filter_by(workflow_id=workflow.id).delete()
-        
-        # Delete workflow
-        db.session.delete(workflow)
-        db.session.commit()
-        
-        logger.info(f"Deleted workflow: {workflow.name}")
-        return jsonify({'success': True})
-        
-    except Exception as e:
-        db.session.rollback()
-        logger.error(f"Error deleting workflow: {e}")
-        return jsonify({'error': str(e)}), 400
-
-@app.route('/api/workflows/<int:workflow_id>/toggle', methods=['POST'])
-@require_admin
-def api_toggle_workflow(workflow_id):
-    """Toggle workflow active status"""
-    try:
-        workflow = Workflow.query.get_or_404(workflow_id)
-        workflow.is_active = not workflow.is_active
-        workflow.updated_at = datetime.utcnow()
-        
-        db.session.commit()
-        
-        status = "aktiviert" if workflow.is_active else "deaktiviert"
-        logger.info(f"Workflow {workflow.name} {status}")
-        
-        return jsonify({'success': True, 'is_active': workflow.is_active})
-        
-    except Exception as e:
-        db.session.rollback()
-        logger.error(f"Error toggling workflow: {e}")
-        return jsonify({'error': str(e)}), 400
-
-# API Routes
-@app.route('/api/assistants', methods=['GET'])
-@require_admin
-def api_get_assistants():
-    """Get all assistants"""
-    assistants = Assistant.query.order_by(Assistant.order_index.asc()).all()
-    return jsonify([{
-        'id': a.id,
-        'name': a.name,
-        'assistant_id': a.assistant_id,
-        'role': a.role,
-        'description': a.description,
-        'is_active': a.is_active,
-        'model': a.model
-    } for a in assistants])
-
-@app.route('/api/assistants/<int:assistant_id>', methods=['GET'])
-@require_admin
-def api_get_assistant(assistant_id):
-    """Get specific assistant"""
-    assistant = Assistant.query.get_or_404(assistant_id)
-    return jsonify({
-        'id': assistant.id,
-        'name': assistant.name,
-        'assistant_id': assistant.assistant_id,
-        'role': assistant.role,
-        'description': assistant.description,
-        'instructions': assistant.instructions,
-        'model': assistant.model,
-        'is_active': assistant.is_active,
-        'order_index': assistant.order_index,
-        'temperature': assistant.temperature,
-        'enabled_tools': assistant.enabled_tools
-    })
-
-@app.route('/api/assistants/<int:assistant_id>', methods=['PUT'])
-@require_admin
-def api_update_assistant(assistant_id):
-    """Update assistant"""
-    assistant = Assistant.query.get_or_404(assistant_id)
-    data = request.get_json()
-    
-    for key, value in data.items():
-        if hasattr(assistant, key):
-            setattr(assistant, key, value)
-    
-    assistant.updated_at = datetime.utcnow()
-    db.session.commit()
-    
-    return jsonify({'success': True})
-
-@app.route('/api/assistants/<int:assistant_id>/toggle', methods=['POST'])
-@require_admin
-def api_toggle_assistant(assistant_id):
-    """Toggle assistant active status"""
-    assistant = Assistant.query.get_or_404(assistant_id)
-    assistant.is_active = not assistant.is_active
-    assistant.updated_at = datetime.utcnow()
-    db.session.commit()
-    
-    return jsonify({'success': True, 'is_active': assistant.is_active})
-
-# The new code block for creating assistants via POST
-@app.route('/api/assistants', methods=['POST'])
-@require_admin
-def api_create_assistant():
-    """Create a new assistant"""
-    try:
-        data = request.get_json()
-
-        # Basic validation - role is now optional for flexible workflow system
-        required_fields = ['name', 'assistant_id']
-        for field in required_fields:
-            if field not in data or not data[field]:
-                return jsonify({'error': f'Feld "{field}" fehlt'}), 400
-
-        # Parse enabled_tools (can be list or JSON string)
-        enabled_tools = data.get('enabled_tools', '[]')
-        if isinstance(enabled_tools, str):
-            try:
-                enabled_tools_parsed = json.loads(enabled_tools)
-            except Exception:
-                enabled_tools_parsed = []
-        else:
-            enabled_tools_parsed = enabled_tools
-
-        assistant = Assistant(
-            name=data['name'],
-            assistant_id=data['assistant_id'],
-            role=data.get('role'),  # Optional for flexible workflow system
-            description=data.get('description', ''),
-            instructions=data.get('instructions', ''),
-            model=data.get('model', 'gpt-4o'),
-            order_index=int(data.get('order_index', 99)),
-            is_active=bool(data.get('is_active', True)),
-            assistant_type=data.get('assistant_type', 'custom'),  # New field
-            temperature=float(data.get('temperature', 0.7)),
-            top_p=float(data.get('top_p', 1.0)),
-            max_tokens=int(data.get('max_tokens', 2000)),
-            frequency_penalty=float(data.get('frequency_penalty', 0.0)),
-            presence_penalty=float(data.get('presence_penalty', 0.0)),
-            retry_attempts=int(data.get('retry_attempts', 3)),
-            timeout_seconds=int(data.get('timeout_seconds', 180)),
-            error_handling=data.get('error_handling', 'graceful'),
-            response_limit=int(data.get('response_limit', 30)),
-            context_window=int(data.get('context_window', 128000)),
-            behavior_preset=data.get('behavior_preset', 'balanced'),
-            custom_system_message=data.get('custom_system_message'),
-            enabled_tools=json.dumps(enabled_tools_parsed)
-        )
-        db.session.add(assistant)
-        db.session.commit()
-
-        logger.info(f"New assistant created: {assistant.name} ({assistant.role})")
-        return jsonify({'id': assistant.id, 'success': True}), 201
-    except Exception as e:
-        logger.error(f"Error creating assistant: {e}")
-        db.session.rollback()
-        return jsonify({'error': str(e)}), 500
-
-# Workflow Management API Endpoints
-
-@app.route('/api/workflows', methods=['GET', 'POST'])
-@require_admin
-def api_workflows():
-    """Get all workflows or create new workflow"""
-    if request.method == 'GET':
-        workflows = Workflow.query.all()
-        return jsonify([{
-            'id': w.id,
-            'name': w.name,
-            'description': w.description,
-            'workflow_type': w.workflow_type,
-            'is_active': w.is_active,
-            'is_default': w.is_default,
-            'created_at': w.created_at.isoformat() if w.created_at else None
-        } for w in workflows])
-    
-    if request.method == 'POST':
-        try:
-            data = request.get_json()
-            workflow = Workflow(
-                name=data['name'],
-                description=data.get('description', ''),
-                workflow_type=data.get('workflow_type', 'course_creation'),
-                is_active=data.get('is_active', True),
-                is_default=data.get('is_default', False),
-                created_by=session.get('user_id')
-            )
-            db.session.add(workflow)
-            db.session.commit()
-            
-            return jsonify({'id': workflow.id, 'success': True}), 201
-        except Exception as e:
-            logger.error(f"Error creating workflow: {e}")
-            db.session.rollback()
-            return jsonify({'error': str(e)}), 500
-
-@app.route('/api/workflows/<int:workflow_id>/steps', methods=['GET', 'POST'])
-@require_admin
-def api_workflow_steps(workflow_id):
-    """Get workflow steps or add new step"""
-    if request.method == 'GET':
-        steps = WorkflowStep.query.filter_by(workflow_id=workflow_id).order_by(WorkflowStep.order_index).all()
-        return jsonify([{
-            'id': s.id,
-            'workflow_id': s.workflow_id,
-            'assistant_id': s.assistant_id,
-            'assistant_name': s.assistant.name if s.assistant else None,
-            'agent_role': s.agent_role,  # Legacy support
-            'step_name': s.step_name,
-            'order_index': s.order_index,
-            'is_enabled': s.is_enabled,
-            'custom_prompt': s.custom_prompt,
-            'step_type': s.step_type
-        } for s in steps])
-    
-    if request.method == 'POST':
-        try:
-            data = request.get_json()
-            step = WorkflowStep(
-                workflow_id=workflow_id,
-                assistant_id=data['assistant_id'],
-                step_name=data['step_name'],
-                order_index=data['order_index'],
-                is_enabled=data.get('is_enabled', True),
-                custom_prompt=data.get('custom_prompt', ''),
-                step_type=data.get('step_type', 'assistant_call')
-            )
-            db.session.add(step)
-            db.session.commit()
-            
-            return jsonify({'id': step.id, 'success': True}), 201
-        except Exception as e:
-            logger.error(f"Error creating workflow step: {e}")
-            db.session.rollback()
-            return jsonify({'error': str(e)}), 500
-
-@app.route('/api/workflows/<int:workflow_id>/steps/<int:step_id>', methods=['PUT', 'DELETE'])
-@require_admin
-def api_workflow_step_detail(workflow_id, step_id):
-    """Update or delete workflow step"""
-    step = WorkflowStep.query.filter_by(id=step_id, workflow_id=workflow_id).first_or_404()
-    
-    if request.method == 'PUT':
-        try:
-            data = request.get_json()
-            for key, value in data.items():
-                if hasattr(step, key):
-                    setattr(step, key, value)
-            db.session.commit()
-            return jsonify({'success': True})
-        except Exception as e:
-            logger.error(f"Error updating workflow step: {e}")
-            db.session.rollback()
-            return jsonify({'error': str(e)}), 500
-    
-    if request.method == 'DELETE':
-        try:
-            db.session.delete(step)
-            db.session.commit()
-            return jsonify({'success': True})
-        except Exception as e:
-            logger.error(f"Error deleting workflow step: {e}")
-            db.session.rollback()
-            return jsonify({'error': str(e)}), 500
-
-# Course Management API Endpoints
-
-@app.route('/api/courses', methods=['GET'])
-def api_get_courses():
-    """Get all courses for the current user"""
-    try:
-        user_id = session.get('user_id')
-        if not user_id:
-            return jsonify({'error': 'Not authenticated'}), 401
-        
-        courses = Course.query.filter_by(user_id=user_id).order_by(Course.created_at.desc()).all()
-        
-        course_list = []
-        for course in courses:
-            # Get sections count
-            sections_count = CourseSection.query.filter_by(course_id=course.id).count()
-            
-            course_data = {
-                'id': course.id,
-                'title': course.title,
-                'description': course.description,
-                'course_topic': course.course_topic,
-                'target_audience': course.target_audience,
-                'estimated_duration': course.estimated_duration,
-                'status': course.status,
-                'quality_score': course.quality_score,
-                'content_length': course.content_length,
-                'sections_count': sections_count,
-                'created_at': course.created_at.isoformat() if course.created_at else None,
-                'updated_at': course.updated_at.isoformat() if course.updated_at else None
-            }
-            course_list.append(course_data)
-        
-        return jsonify(course_list)
-        
-    except Exception as e:
-        logger.error(f"Error fetching courses: {e}")
-        return jsonify({'error': str(e)}), 500
-
-@app.route('/api/courses/<int:course_id>', methods=['GET'])
-def api_get_course(course_id):
-    """Get a specific course with full content"""
-    try:
-        user_id = session.get('user_id')
-        if not user_id:
-            return jsonify({'error': 'Not authenticated'}), 401
-        
-        course = Course.query.filter_by(id=course_id, user_id=user_id).first()
-        if not course:
-            return jsonify({'error': 'Course not found'}), 404
-        
-        # Get course sections
-        sections = CourseSection.query.filter_by(course_id=course.id).order_by(CourseSection.section_order).all()
-        
-        course_data = {
-            'id': course.id,
-            'title': course.title,
-            'description': course.description,
-            'course_topic': course.course_topic,
-            'target_audience': course.target_audience,
-            'estimated_duration': course.estimated_duration,
-            'full_content': course.full_content,
-            'outline': course.outline,
-            'learning_objectives': course.learning_objectives,
-            'status': course.status,
-            'quality_score': course.quality_score,
-            'content_length': course.content_length,
-            'created_at': course.created_at.isoformat() if course.created_at else None,
-            'updated_at': course.updated_at.isoformat() if course.updated_at else None,
-            'sections': [{
-                'id': section.id,
-                'title': section.section_title,
-                'content': section.section_content,
-                'order': section.section_order,
-                'type': section.section_type,
-                'learning_objectives': section.learning_objectives,
-                'estimated_duration': section.estimated_duration
-            } for section in sections]
-        }
-        
-        return jsonify(course_data)
-        
-    except Exception as e:
-        logger.error(f"Error fetching course {course_id}: {e}")
-        return jsonify({'error': str(e)}), 500
-
-@app.route('/api/courses/<int:course_id>', methods=['PUT'])
-def api_update_course(course_id):
-    """Update course details"""
-    try:
-        user_id = session.get('user_id')
-        if not user_id:
-            return jsonify({'error': 'Not authenticated'}), 401
-        
-        course = Course.query.filter_by(id=course_id, user_id=user_id).first()
-        if not course:
-            return jsonify({'error': 'Course not found'}), 404
-        
-        data = request.get_json()
-        
-        # Update allowed fields
-        if 'title' in data:
-            course.title = data['title']
-        if 'description' in data:
-            course.description = data['description']
-        if 'status' in data:
-            course.status = data['status']
-        if 'target_audience' in data:
-            course.target_audience = data['target_audience']
-        if 'estimated_duration' in data:
-            course.estimated_duration = data['estimated_duration']
-        
-        db.session.commit()
-        logger.info(f"Updated course {course_id}: {course.title}")
-        
-        return jsonify({'success': True, 'message': 'Course updated successfully'})
-        
-    except Exception as e:
-        db.session.rollback()
-        logger.error(f"Error updating course {course_id}: {e}")
-        return jsonify({'error': str(e)}), 500
-
-@app.route('/api/courses/<int:course_id>', methods=['DELETE'])
-def api_delete_course(course_id):
-    """Delete a course"""
-    try:
-        user_id = session.get('user_id')
-        if not user_id:
-            return jsonify({'error': 'Not authenticated'}), 401
-        
-        course = Course.query.filter_by(id=course_id, user_id=user_id).first()
-        if not course:
-            return jsonify({'error': 'Course not found'}), 404
-        
-        # Delete course sections first
-        CourseSection.query.filter_by(course_id=course.id).delete()
-        
-        # Delete course
-        db.session.delete(course)
-        db.session.commit()
-        
-        logger.info(f"Deleted course {course_id}: {course.title}")
-        
-        return jsonify({'success': True, 'message': 'Course deleted successfully'})
-        
-    except Exception as e:
-        db.session.rollback()
-        logger.error(f"Error deleting course {course_id}: {e}")
-        return jsonify({'error': str(e)}), 500
-
-# SocketIO Events
-@socketio.on('connect')
-def handle_connect():
-    """Handle client connection"""
-    if 'user_id' not in session:
-        logger.warning("SocketIO connect denied - no user_id in session")
-        return False
-    
-    user_id = session['user_id']
-    username = session.get('username', 'Unknown')
-    
-    try:
-        # Join user-specific room so orchestrator can emit directly
-        join_room(f'session_{user_id}')
-        
-        logger.info(f"SocketIO connection: {username} (ID: {user_id}) - joined room session_{user_id}")
-        emit('status', {'message': f'Connected as {username}'})
-        
-        # Emit connection success to frontend
-        emit('connection_status', {'connected': True, 'user_id': user_id, 'username': username})
-        
-    except Exception as e:
-        logger.error(f"Error in SocketIO connect for user {user_id}: {e}")
-        return False
-
-@socketio.on('disconnect')
-def handle_disconnect():
-    """Handle client disconnection"""
-    user_id = session.get('user_id')
-    username = session.get('username', 'Unknown')
-    
-    if user_id:
-        try:
-            leave_room(f'session_{user_id}')
-            logger.info(f"SocketIO disconnection: {username} (ID: {user_id}) - left room session_{user_id}")
-            
-            if user_id in orchestrators:
-                try:
-                    del orchestrators[user_id]
-                    logger.info(f"Cleaned up orchestrator for disconnected user {user_id}")
-                except Exception as e:
-                    logger.error(f"Error cleaning orchestrator for user {user_id}: {e}")
-        except Exception as e:
-            logger.error(f"Error in SocketIO disconnect for user {user_id}: {e}")
-    else:
-        logger.warning("SocketIO disconnect - no user_id in session")
-
-# COMPATIBILITY: Support both event names from frontend
-@socketio.on('user_message')
-def handle_user_message_compat(data):
-    """Handle user_message event (compatibility with app.py frontend)"""
-    logger.info("üì® RECEIVED user_message event (compatibility mode)")
-    return handle_message(data)
-
-@socketio.on('send_message')
-def handle_message(data):
-    """Handle chat message from user"""
-    logger.info(f"üì® RECEIVE MESSAGE EVENT: {data}")
-    
-    if 'user_id' not in session:
-        logger.warning("‚ùå MESSAGE REJECTED: No user_id in session")
-        emit('error', {'message': 'Not authenticated'})
-        return
-    
-    user_id = session['user_id']
-    message = data.get('message', '').strip()
-    
-    logger.info(f"üì® Processing message from user {user_id}: '{message}'")
-    
-    if not message:
-        logger.warning(f"‚ùå Empty message from user {user_id}")
-        return
-    
-    # CRITICAL FIX: Ensure Flask app context for SQLAlchemy
-    with app.app_context():
-        # Cleanup old orchestrators before creating new ones
-        cleanup_orchestrators()
-        
-        # Get or create orchestrator for this user with activity tracking
-        if user_id not in orchestrators:
-            try:
-                logger.info(f"ü§ñ Creating new orchestrator for user {user_id}")
-                orchestrator = DynamicChatOrchestrator(
-                    socketio=socketio,
-                    session_id=user_id
-                )
-                
-                # Store with activity tracking
-                orchestrators[user_id] = {
-                    'orchestrator': orchestrator,
-                    'last_activity': time.time()
-                }
-                
-                logger.info(f"‚úÖ Created new orchestrator for user {user_id}")
-            except Exception as e:
-                logger.error(f"‚ùå Error creating orchestrator for user {user_id}: {e}")
-                emit('error', {'message': 'Failed to initialize chat system'})
-                return
-        else:
-            logger.info(f"üîÑ Using existing orchestrator for user {user_id}")
-            # Update activity timestamp
-            if isinstance(orchestrators[user_id], dict):
-                orchestrators[user_id]['last_activity'] = time.time()
-        
-        # Process message
-        try:
-            if isinstance(orchestrators[user_id], dict):
-                orchestrator = orchestrators[user_id]['orchestrator']
-            else:
-                # Legacy format - convert
-                orchestrator = orchestrators[user_id]
-                orchestrators[user_id] = {
-                    'orchestrator': orchestrator,
-                    'last_activity': time.time()
-                }
-            
-            # CRITICAL FIX: Echo user message to frontend so it appears in chat
-            username = session.get('username', f'User {user_id}')
-            logger.info(f"üì§ Echoing user message to frontend: '{message}' from {username}")
-            
-            emit('new_message', {
-                'sender': username,
-                'message': message,
-                'timestamp': datetime.utcnow().strftime('%H:%M:%S'),
-                'type': 'user'
-            }, room=f'session_{user_id}')
-            
-            logger.info(f"üöÄ Starting message processing for user {user_id}")
-            orchestrator.process_message(message, user_id)
-            logger.info(f"‚úÖ Message processing initiated for user {user_id}")
-            
-        except Exception as e:
-            logger.error(f"‚ùå Error processing message for user {user_id}: {e}")
-            logger.error(f"‚ùå Exception details: {type(e).__name__}: {str(e)}")
-            emit('error', {'message': 'Error processing your message'})
-
-# Chat cleanup scheduler
-scheduler = BackgroundScheduler()
-
-def cleanup_chats():
-    """Scheduled job to clean up old chats and orchestrators"""
-    try:
-        retention_days = int(os.environ.get('RETENTION_DAYS', 14))
-        logger.info(f"Running chat cleanup job (retention {retention_days} days)...")
-        
-        with app.app_context():
-            cutoff_date = datetime.utcnow() - timedelta(days=retention_days)
-            
-            # Count before cleanup for monitoring
-            old_sessions_count = ChatSession.query.filter(ChatSession.updated_at < cutoff_date).count()
-            
-            if old_sessions_count > 0:
-                # Delete old messages in batches to avoid memory spikes
-                batch_size = 100
-                deleted_total = 0
-                
-                while True:
-                    old_sessions = ChatSession.query.filter(ChatSession.updated_at < cutoff_date).limit(batch_size).all()
-                    if not old_sessions:
-                        break
-                    
-                    for session in old_sessions:
-                        # Delete messages first
-                        ChatMessage.query.filter_by(session_id=session.id).delete()
-                        # Delete session
-                        db.session.delete(session)
-                    
-                    db.session.commit()
-                    deleted_total += len(old_sessions)
-                    
-                    # Memory management
-                    if deleted_total % 500 == 0:
-                        gc.collect()
-                
-                logger.info(f"Chat cleanup completed: {deleted_total} sessions deleted")
-            else:
-                logger.info("Chat cleanup: no old sessions to delete")
-            
-            # Also cleanup orchestrators
-            cleanup_orchestrators()
-            
-            # Force garbage collection after cleanup
-            gc.collect()
-    
-    except Exception as e:
-        logger.error(f"Chat cleanup job failed: {e}")
-        # Force garbage collection even on error
-        gc.collect()
-
-# Schedule cleanup jobs - optimized for Railway
-scheduler.add_job(
-    func=cleanup_chats,
-    trigger=IntervalTrigger(hours=6),  # Every 6 hours instead of daily
-    id='chat_cleanup_job',
-    name='Chat and memory cleanup',
-    replace_existing=True
-)
-
-# Additional memory cleanup every 30 minutes
-scheduler.add_job(
-    func=cleanup_orchestrators,
-    trigger=IntervalTrigger(minutes=30),
-    id='memory_cleanup_job',
-    name='Memory cleanup',
-    replace_existing=True
-)
-
-# Initialize database immediately (wichtig f√ºr gunicorn/Railway)
-init_database()
-
-# CREATE SPECIALIZED ASSISTANTS: Add missing assistant roles
-def create_specialized_assistants():
-    """Create specialized assistants if they don't exist"""
-    try:
-        with app.app_context():
-            # Check if specialized assistants exist
-            existing_roles = set(a.role for a in Assistant.query.all())
-            
-            specialized_assistants = [
-                {
-                    'name': 'Content Creator',
-                    'assistant_id': 'asst_content_creator_v1',
-                    'role': 'content_creator',
-                    'description': 'Spezialist f√ºr die Erstellung von strukturierten Lerninhalten',
-                    'instructions': '''Du bist ein Experte f√ºr die Erstellung von hochwertigen Lerninhalten.
-
-DEINE AUFGABE: Erstelle strukturierte, professionelle Kursinhalte basierend auf dem gegebenen Thema.
-
-STRUKTUR DEINER KURSE:
-1. Klare Lernziele (3-5 pro Kapitel)
-2. Logischer Aufbau (Einf√ºhrung ‚Üí Hauptinhalt ‚Üí Beispiele ‚Üí Zusammenfassung)
-3. Praktische Beispiele und Analogien
-4. Verst√§ndliche Sprache (max. 20 W√∂rter pro Satz)
-5. Strukturierte Gliederung mit √úberschriften
-
-QUALIT√ÑTSKRITERIEN:
-- Faktisch korrekt und aktuell
-- Zielgruppengerecht formuliert
-- Interaktive Elemente einbauen
-- Praxisbezug herstellen
-- Konsistente Terminologie verwenden
-
-Erstelle immer vollst√§ndige, sofort einsetzbare Kursinhalte!''',
-                    'model': 'gpt-4o',
-                    'temperature': 0.3,
-                    'max_tokens': 3000,
-                    'order_index': 2
-                },
-                {
-                    'name': 'Didactic Expert',
-                    'assistant_id': 'asst_didactic_expert_v1',
-                    'role': 'didactic_expert',
-                    'description': 'Spezialist f√ºr didaktische Optimierung von Lerninhalten',
-                    'instructions': '''Du bist ein Didaktik-Experte f√ºr die Optimierung von Lerninhalten.
-
-DEINE AUFGABE: Optimiere vorhandene Kursinhalte didaktisch und methodisch.
-
-OPTIMIERUNGSBEREICHE:
-1. LERNZIELE: Messbare, klare Ziele formulieren (SMART-Kriterien)
-2. PROGRESSION: Logische Lernpfade mit ansteigendem Schwierigkeitsgrad
-3. INTERAKTION: Fragen, √úbungen, Reflexionspunkte einbauen
-4. VERST√ÑNDLICHKEIT: Komplexe Konzepte vereinfachen
-5. MOTIVATION: Relevanz und Nutzen klar kommunizieren
-
-DIDAKTISCHE METHODEN:
-- Advance Organizer einsetzen
-- Chunking f√ºr bessere Merkf√§higkeit
-- Beispiele vor Regeln pr√§sentieren
-- Wiederholung in verschiedenen Kontexten
-- Aktives Lernen f√∂rdern
-
-AUSGABE: Der vollst√§ndig optimierte Kursinhalt (nicht nur Verbesserungsvorschl√§ge)!''',
-                    'model': 'gpt-4o',
-                    'temperature': 0.4,
-                    'max_tokens': 3000,
-                    'order_index': 3
-                },
-                {
-                    'name': 'Quality Checker',
-                    'assistant_id': 'asst_quality_checker_v1',
-                    'role': 'quality_checker',
-                    'description': 'Spezialist f√ºr Qualit√§tskontrolle und finale Pr√ºfung',
-                    'instructions': '''Du bist ein Qualit√§ts-Experte f√ºr die finale Pr√ºfung von Kursinhalten.
-
-DEINE AUFGABE: F√ºhre eine kritische Qualit√§tspr√ºfung durch und korrigiere M√§ngel.
-
-PR√úFKRITERIEN:
-1. STRUKTUR: Logischer Aufbau, klare Gliederung, vollst√§ndige Kapitel
-2. INHALT: Faktische Korrektheit, Aktualit√§t, Praxisbezug
-3. SPRACHE: Verst√§ndlichkeit, Konsistenz, angemessener Ton
-4. DIDAKTIK: Lernziele messbar, Progression erkennbar, Beispiele vorhanden
-5. VOLLST√ÑNDIGKEIT: Alle Aspekte des Themas abgedeckt
-
-QUALIT√ÑTS-STANDARDS:
-- Mindestens 3 Lernziele pro Hauptkapitel
-- Praktische Beispiele in jedem Abschnitt
-- Klare Zusammenfassungen
-- Einheitliche Terminologie
-- Logische Kapitel√ºberg√§nge
-
-AUSGABE: Der vollst√§ndig korrigierte und qualit√§tsgesicherte Kurs!''',
-                    'model': 'gpt-4o',
-                    'temperature': 0.2,
-                    'max_tokens': 3000,
-                    'order_index': 4
-                }
-            ]
-            
-            created_count = 0
-            for assistant_data in specialized_assistants:
-                if assistant_data['role'] not in existing_roles:
-                    assistant = Assistant(
-                        name=assistant_data['name'],
-                        assistant_id=assistant_data['assistant_id'],
-                        role=assistant_data['role'],
-                        description=assistant_data['description'],
-                        instructions=assistant_data['instructions'],
-                        model=assistant_data['model'],
-                        temperature=assistant_data['temperature'],
-                        max_tokens=assistant_data['max_tokens'],
-                        order_index=assistant_data['order_index'],
-                        is_active=True,
-                        enabled_tools='[]'  # No tools needed for specialized assistants
-                    )
-                    db.session.add(assistant)
-                    created_count += 1
-                    logger.info(f"‚úÖ Created specialized assistant: {assistant_data['name']} ({assistant_data['role']})")
-            
-            if created_count > 0:
-                db.session.commit()
-                logger.info(f"üéØ Created {created_count} specialized assistants")
-            else:
-                logger.info("üéØ All specialized assistants already exist")
-                
-    except Exception as e:
-        logger.error(f"Error creating specialized assistants: {e}")
-        db.session.rollback()
-
-# Create specialized assistants
-create_specialized_assistants()
-
-# FORCE UPDATE: Ensure all assistants have 300s timeout (Safety measure)
-with app.app_context():
-    try:
-        force_assistants = Assistant.query.all()
-        for assistant in force_assistants:
-            if assistant.timeout_seconds != 300:
-                old = assistant.timeout_seconds
-                assistant.timeout_seconds = 300
-                logger.info(f"üîß FORCE UPDATE: {assistant.name} timeout {old}s ‚Üí 300s")
-        db.session.commit()
-        logger.info("üîß FORCE UPDATE: All assistants verified with 300s timeout")
-    except Exception as e:
-        logger.error(f"Force update failed: {e}")
-
-# Start scheduler
-scheduler.start()
-logger.info("Scheduler started")
-logger.info("üîß ROUTES LOADED: Including new_project route fix for Railway")
-logger.info("üöÄ SQLALCHEMY 2.0 + GEVENT: v2025-01-25-08:35 - Database compatibility fixes deployed")
-
-if __name__ == '__main__':
-    # Get port from environment (Railway sets this)
-    port = int(os.environ.get('PORT', 5000))
-    
-    logger.info("Starting Intelligentes KI-Kursstudio (Railway Version)...")
-    logger.info(f"Database: {app.config['SQLALCHEMY_DATABASE_URI'][:50]}...")
-    logger.info("üöÄ VERSION: 2025-01-24-v2 - NEW_PROJECT ROUTE INCLUDED")
-    
-    # Run the app
-    socketio.run(app, host='0.0.0.0', port=port, debug=False) 
\ No newline at end of file
diff --git a/app_simplified.py b/app_simplified.py
new file mode 100644
index 0000000..0536ef6
--- /dev/null
+++ b/app_simplified.py
@@ -0,0 +1,435 @@
+"""
+Kiki Chat - Vereinfachtes KI-Kursstudio
+Optimiert f√ºr Railway Deployment
+
+Vereinfachte Version mit direkter OpenAI Assistant Integration
+"""
+
+import os
+import logging
+from datetime import datetime
+from typing import Dict, Optional, Any
+
+from flask import Flask, render_template, request, redirect, url_for, flash, session, jsonify
+from flask_socketio import SocketIO, emit, join_room, leave_room
+from flask_sqlalchemy import SQLAlchemy
+from werkzeug.security import generate_password_hash, check_password_hash
+from werkzeug.utils import secure_filename
+from dotenv import load_dotenv
+
+# Load environment variables
+load_dotenv()
+
+# Flask App Configuration
+app = Flask(__name__)
+app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'kiki-chat-secret-key-change-in-production')
+app.config['UPLOAD_FOLDER'] = os.environ.get('UPLOAD_FOLDER', 'uploads')
+app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB
+
+# Database Configuration (Railway compatible)
+database_url = os.environ.get('DATABASE_URL', 'sqlite:///kiki_chat.db')
+if database_url.startswith('postgres://'):
+    database_url = database_url.replace('postgres://', 'postgresql://', 1)
+app.config['SQLALCHEMY_DATABASE_URI'] = database_url
+app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
+
+# Initialize extensions
+db = SQLAlchemy(app)
+socketio = SocketIO(app, cors_allowed_origins="*", async_mode='threading')
+
+# Logging
+logging.basicConfig(level=logging.INFO)
+logger = logging.getLogger(__name__)
+
+# Create upload folder
+os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
+
+# ==============================================
+# DATABASE MODELS (Simplified)
+# ==============================================
+
+class User(db.Model):
+    id = db.Column(db.Integer, primary_key=True)
+    username = db.Column(db.String(80), unique=True, nullable=False)
+    password_hash = db.Column(db.String(255), nullable=False)
+    role = db.Column(db.String(20), default='user')
+    created_at = db.Column(db.DateTime, default=datetime.utcnow)
+    last_login = db.Column(db.DateTime)
+
+class Project(db.Model):
+    id = db.Column(db.Integer, primary_key=True)
+    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
+    title = db.Column(db.String(200), nullable=False)
+    description = db.Column(db.Text)
+    created_at = db.Column(db.DateTime, default=datetime.utcnow)
+
+class ChatSession(db.Model):
+    id = db.Column(db.Integer, primary_key=True)
+    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
+    project_id = db.Column(db.Integer, db.ForeignKey('project.id'))
+    title = db.Column(db.String(200), default='New Chat')
+    created_at = db.Column(db.DateTime, default=datetime.utcnow)
+
+class ChatMessage(db.Model):
+    id = db.Column(db.Integer, primary_key=True)
+    session_id = db.Column(db.Integer, db.ForeignKey('chat_session.id'), nullable=False)
+    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
+    message_type = db.Column(db.String(20), nullable=False)  # 'user', 'assistant', 'system'
+    content = db.Column(db.Text, nullable=False)
+    created_at = db.Column(db.DateTime, default=datetime.utcnow)
+
+class UploadedFile(db.Model):
+    id = db.Column(db.Integer, primary_key=True)
+    project_id = db.Column(db.Integer, db.ForeignKey('project.id'), nullable=False)
+    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
+    filename = db.Column(db.String(255), nullable=False)
+    file_path = db.Column(db.String(500), nullable=False)
+    file_size = db.Column(db.Integer, nullable=False)
+    processed = db.Column(db.Boolean, default=False)
+    chunks_count = db.Column(db.Integer, default=0)
+    doc_id = db.Column(db.String(100))
+    created_at = db.Column(db.DateTime, default=datetime.utcnow)
+
+class Course(db.Model):
+    id = db.Column(db.Integer, primary_key=True)
+    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
+    project_id = db.Column(db.Integer, db.ForeignKey('project.id'))
+    title = db.Column(db.String(200), nullable=False)
+    description = db.Column(db.Text)
+    full_content = db.Column(db.Text)
+    quality_score = db.Column(db.Float)
+    content_length = db.Column(db.Integer)
+    status = db.Column(db.String(20), default='draft')
+    created_at = db.Column(db.DateTime, default=datetime.utcnow)
+
+# ==============================================
+# AUTHENTICATION HELPERS
+# ==============================================
+
+def login_required(f):
+    """Decorator for login requirement"""
+    from functools import wraps
+    
+    @wraps(f)
+    def decorated_function(*args, **kwargs):
+        if 'user_id' not in session:
+            return redirect(url_for('login'))
+        return f(*args, **kwargs)
+    return decorated_function
+
+def admin_required(f):
+    """Decorator for admin privileges"""
+    from functools import wraps
+    
+    @wraps(f)
+    def decorated_function(*args, **kwargs):
+        if 'user_id' not in session:
+            return redirect(url_for('login'))
+        
+        user = User.query.get(session['user_id'])
+        if not user or user.role != 'admin':
+            flash('Admin rights required', 'error')
+            return redirect(url_for('dashboard'))
+        return f(*args, **kwargs)
+    return decorated_function
+
+# ==============================================
+# ROUTES
+# ==============================================
+
+@app.route('/')
+def index():
+    """Homepage - redirect to chat"""
+    return redirect(url_for('chat'))
+
+@app.route('/login', methods=['GET', 'POST'])
+def login():
+    """Login page"""
+    if request.method == 'POST':
+        username = request.form['username']
+        password = request.form['password']
+        
+        user = User.query.filter_by(username=username).first()
+        
+        if user and check_password_hash(user.password_hash, password):
+            session['user_id'] = user.id
+            session['username'] = user.username
+            session['role'] = user.role
+            
+            user.last_login = datetime.utcnow()
+            db.session.commit()
+            
+            flash(f'Welcome, {user.username}!', 'success')
+            return redirect(url_for('dashboard'))
+        else:
+            flash('Invalid credentials', 'error')
+    
+    return render_template('login.html')
+
+@app.route('/logout')
+def logout():
+    """Logout and clear session"""
+    username = session.get('username', 'Unknown')
+    session.clear()
+    flash('Successfully logged out', 'success')
+    logger.info(f"User {username} logged out")
+    return redirect(url_for('login'))
+
+@app.route('/dashboard')
+@login_required
+def dashboard():
+    """User dashboard"""
+    user = User.query.get(session['user_id'])
+    projects = Project.query.filter_by(user_id=session['user_id']).order_by(Project.created_at.desc()).all()
+    
+    return render_template('dashboard.html', user=user, projects=projects)
+
+@app.route('/chat')
+def chat():
+    """Main chat interface - simplified for MVP"""
+    project_id = request.args.get('project_id', 'default')
+    session_id = request.args.get('session_id')
+    
+    # Mock user for simplified demo
+    mock_user = {
+        'id': 1,
+        'username': 'demo_user',
+        'role': 'user'
+    }
+    
+    if not session_id:
+        # Create new chat session
+        try:
+            new_session = ChatSession(
+                user_id=mock_user['id'], 
+                project_id=int(project_id) if project_id != 'default' else None,
+                title='New Chat'
+            )
+            db.session.add(new_session)
+            db.session.commit()
+            session_id = new_session.id
+        except:
+            # Fallback to timestamp-based session
+            session_id = f"demo_{int(datetime.now().timestamp())}"
+    
+    return render_template('chat_simple.html', 
+                         project_id=project_id, 
+                         session_id=session_id, 
+                         user=mock_user)
+
+@app.route('/new-project', methods=['POST'])
+@login_required
+def new_project():
+    """Create new project"""
+    title = request.form.get('title', '').strip()
+    description = request.form.get('description', '').strip()
+    
+    if not title:
+        flash('Project title is required', 'error')
+        return redirect(url_for('dashboard'))
+    
+    project = Project(
+        user_id=session['user_id'],
+        title=title,
+        description=description
+    )
+    db.session.add(project)
+    db.session.commit()
+    
+    flash(f'Project "{title}" created successfully', 'success')
+    return redirect(url_for('chat', project_id=project.id))
+
+@app.route('/upload-file', methods=['POST'])
+def upload_file():
+    """Simplified file upload for knowledge base"""
+    try:
+        project_id = request.form.get('project_id', 'default')
+        
+        if 'file' not in request.files:
+            return jsonify({'success': False, 'error': 'No file selected'}), 400
+        
+        file = request.files['file']
+        if file.filename == '':
+            return jsonify({'success': False, 'error': 'No file selected'}), 400
+        
+        filename = secure_filename(file.filename)
+        if not filename:
+            return jsonify({'success': False, 'error': 'Invalid filename'}), 400
+        
+        # Save file
+        upload_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
+        file.save(upload_path)
+        
+        # Process with Knowledge Manager (if available)
+        try:
+            from knowledge_manager import get_knowledge_manager
+            km = get_knowledge_manager()
+            
+            numeric_project_id = int(project_id) if project_id != 'default' else 1
+            result = km.process_uploaded_file(
+                file_path=upload_path,
+                project_id=numeric_project_id,
+                user_id=1,  # Mock user
+                filename=filename
+            )
+            
+            if result['success']:
+                return jsonify({
+                    'success': True,
+                    'message': f'File "{filename}" processed successfully',
+                    'details': result
+                })
+            else:
+                return jsonify({'success': False, 'error': result.get('error', 'Processing failed')}), 500
+                
+        except Exception as e:
+            logger.warning(f"Knowledge manager not available: {e}")
+            return jsonify({
+                'success': True,
+                'message': f'File "{filename}" uploaded (knowledge processing unavailable)',
+                'details': {'filename': filename, 'chunks_count': 0}
+            })
+            
+    except Exception as e:
+        logger.error(f"File upload error: {e}")
+        return jsonify({'success': False, 'error': f'Upload error: {str(e)}'}), 500
+
+# ==============================================
+# SOCKETIO EVENTS
+# ==============================================
+
+@socketio.on('connect')
+def handle_connect():
+    """Client connected"""
+    emit('status', {'msg': 'Connected to Kiki Chat'})
+    logger.info("SocketIO connection established")
+
+@socketio.on('join_project')
+def handle_join_project(data):
+    """User joins a chat session"""
+    session_id = data.get('session_id')
+    if not session_id:
+        emit('error_message', {'error': 'session_id missing'})
+        return
+
+    join_room(f'session_{session_id}')
+    emit('status', {'msg': f'Joined chat session {session_id}'})
+    
+    # Load chat history
+    try:
+        messages = ChatMessage.query.filter_by(session_id=session_id).order_by(ChatMessage.created_at.asc()).limit(50).all()
+        
+        for msg in messages:
+            emit('new_message', {
+                'sender': 'AI-Assistant' if msg.message_type == 'assistant' else 'You',
+                'message': msg.content,
+                'timestamp': msg.created_at.strftime('%H:%M:%S'),
+                'type': msg.message_type
+            })
+            
+        if messages:
+            emit('status', {'msg': f'{len(messages)} messages loaded'})
+            
+    except Exception as e:
+        logger.error(f"Error loading chat history: {e}")
+    
+    logger.info(f"User joined session {session_id}")
+
+@socketio.on('leave_project')
+def handle_leave_project(data):
+    """User leaves project chat"""
+    session_id = data.get('session_id')
+    if session_id:
+        leave_room(f'session_{session_id}')
+        logger.info(f"User left session {session_id}")
+
+@socketio.on('user_message')
+def handle_user_message(data):
+    """Process user message and forward to simplified orchestrator"""
+    message = data.get('message', '').strip()
+    session_id = data.get('session_id')
+    project_id = data.get('project_id', 'default')
+    
+    if not message:
+        emit('error_message', {'error': 'Empty message'})
+        return
+    
+    # Mock user
+    mock_user = {'id': 1, 'username': 'demo_user'}
+    
+    # Save user message
+    try:
+        chat_message = ChatMessage(
+            session_id=session_id,
+            user_id=mock_user['id'],
+            message_type='user',
+            content=message
+        )
+        db.session.add(chat_message)
+        db.session.commit()
+    except Exception as e:
+        logger.error(f"Database error saving message: {e}")
+    
+    # Send user message to all participants
+    emit('new_message', {
+        'sender': mock_user['username'],
+        'message': message,
+        'timestamp': datetime.now().strftime('%H:%M:%S'),
+        'type': 'user'
+    }, room=f'session_{session_id}')
+    
+    # Process with simplified orchestrator
+    from simple_orchestrator import get_or_create_orchestrator
+    
+    orchestrator = get_or_create_orchestrator(
+        project_id=str(project_id),
+        session_id=str(session_id),
+        socketio=socketio
+    )
+    
+    # Process message
+    orchestrator.process_message(message, mock_user)
+    
+    logger.info(f"Message from {mock_user['username']} processed: {message[:50]}...")
+
+# ==============================================
+# DATABASE INITIALIZATION
+# ==============================================
+
+def init_database():
+    """Initialize database with default data"""
+    with app.app_context():
+        db.create_all()
+        
+        # Create default admin user if not exists
+        if not User.query.filter_by(username='admin').first():
+            admin_user = User(
+                username='admin',
+                password_hash=generate_password_hash('admin123'),
+                role='admin'
+            )
+            db.session.add(admin_user)
+            
+        # Create default demo user
+        if not User.query.filter_by(username='demo').first():
+            demo_user = User(
+                username='demo',
+                password_hash=generate_password_hash('demo123'),
+                role='user'
+            )
+            db.session.add(demo_user)
+        
+        db.session.commit()
+        logger.info("Database initialized with default users")
+
+# ==============================================
+# APPLICATION STARTUP
+# ==============================================
+
+if __name__ == '__main__':
+    init_database()
+    logger.info("Starting Kiki Chat...")
+    logger.info(f"Upload folder: {app.config['UPLOAD_FOLDER']}")
+    
+    # Development mode
+    socketio.run(app, debug=True, host='0.0.0.0', port=5000)
\ No newline at end of file
diff --git a/init_assistants.py b/init_assistants.py
new file mode 100644
index 0000000..a9420a7
--- /dev/null
+++ b/init_assistants.py
@@ -0,0 +1,49 @@
+"""
+Initialisiert die spezifizierten OpenAI Assistenten in der Datenbank
+"""
+
+import os
+from app_simplified import app, db, User
+from werkzeug.security import generate_password_hash
+
+def init_assistants_and_users():
+    """Initialize database with specified assistants and default users"""
+    
+    with app.app_context():
+        # Create all tables
+        db.create_all()
+        print("‚úÖ Database tables created")
+        
+        # Create default admin user if not exists
+        if not User.query.filter_by(username='admin').first():
+            admin_user = User(
+                username='admin',
+                password_hash=generate_password_hash('admin123'),
+                role='admin'
+            )
+            db.session.add(admin_user)
+            print("‚úÖ Admin user created (admin/admin123)")
+            
+        # Create default demo user if not exists
+        if not User.query.filter_by(username='demo').first():
+            demo_user = User(
+                username='demo',
+                password_hash=generate_password_hash('demo123'),
+                role='user'
+            )
+            db.session.add(demo_user)
+            print("‚úÖ Demo user created (demo/demo123)")
+        
+        db.session.commit()
+        print("‚úÖ Default users initialized")
+        
+        print("\nü§ñ OpenAI Assistants Configuration:")
+        print("The following assistants are configured in simple_orchestrator.py:")
+        print("- Supervisor: asst_19FlW2QtTAIb7Z96f3ukfSre (gpt-4.1-nano)")
+        print("- Der Autor: asst_UCpHRYdDK2uPsb7no8Zw5Z0p (gpt-4.1-nano)")
+        print("- Der P√§dagoge: asst_tmj7Nz75MSwjPSrBf4KV2EIt (gpt-4.1-nano)")
+        print("- Der Pr√ºfer: asst_qH5a6MsVByLHP2ZLQ8gT8jg0 (gpt-4.1-nano)")
+        print("\n‚úÖ Database initialization complete!")
+
+if __name__ == '__main__':
+    init_assistants_and_users()
\ No newline at end of file
diff --git a/railway.json b/railway.json
new file mode 100644
index 0000000..9e4c45e
--- /dev/null
+++ b/railway.json
@@ -0,0 +1,7 @@
+{
+  "deploy": {
+    "startCommand": "gunicorn --worker-class gevent --worker-connections 1000 --workers 1 --bind 0.0.0.0:$PORT app_simplified:app",
+    "restartPolicyType": "ON_FAILURE",
+    "restartPolicyMaxRetries": 10
+  }
+}
\ No newline at end of file
diff --git a/requirements.txt b/requirements.txt
index df77b72..d14ec81 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -2,12 +2,11 @@
 Flask==2.3.3
 Flask-Login==0.6.3
 Flask-SocketIO==5.3.6
+Flask-SQLAlchemy==3.0.5
 gunicorn==21.2.0
 gevent==23.9.1
 
-# Database & ORM
-SQLAlchemy==2.0.25
-Flask-SQLAlchemy==3.0.5
+# Database
 psycopg2-binary==2.9.9
 
 # OpenAI & AI/ML
@@ -18,11 +17,9 @@ numpy==1.26.4
 
 # Utilities
 python-dotenv==1.0.1
-APScheduler==3.10.4
 requests==2.31.0
 Werkzeug==2.3.8
 
 # File Processing
 PyPDF2==3.0.1
-python-docx==1.1.0
-beautifulsoup4==4.12.3 
\ No newline at end of file
+python-docx==1.1.0 
\ No newline at end of file
diff --git a/requirements_simplified.txt b/requirements_simplified.txt
new file mode 100644
index 0000000..255daac
--- /dev/null
+++ b/requirements_simplified.txt
@@ -0,0 +1,25 @@
+# Core Framework
+Flask==2.3.3
+Flask-Login==0.6.3
+Flask-SocketIO==5.3.6
+Flask-SQLAlchemy==3.0.5
+gunicorn==21.2.0
+gevent==23.9.1
+
+# Database
+psycopg2-binary==2.9.9
+
+# OpenAI & AI/ML
+openai>=1.30.0
+chromadb==0.4.24
+sentence-transformers==2.2.2
+numpy==1.26.4
+
+# Utilities
+python-dotenv==1.0.1
+requests==2.31.0
+Werkzeug==2.3.8
+
+# File Processing
+PyPDF2==3.0.1
+python-docx==1.1.0
\ No newline at end of file
diff --git a/simple_orchestrator.py b/simple_orchestrator.py
new file mode 100644
index 0000000..89faafd
--- /dev/null
+++ b/simple_orchestrator.py
@@ -0,0 +1,586 @@
+"""
+Vereinfachter Chat-Orchestrator f√ºr Kiki Chat
+Direkte Integration mit spezifizierten OpenAI Assistenten
+
+Unterst√ºtzte Assistenten:
+- Supervisor (asst_19FlW2QtTAIb7Z96f3ukfSre) - gpt-4.1-nano
+- Der Autor (asst_UCpHRYdDK2uPsb7no8Zw5Z0p) - gpt-4.1-nano  
+- Der P√§dagoge (asst_tmj7Nz75MSwjPSrBf4KV2EIt) - gpt-4.1-nano
+- Der Pr√ºfer (asst_qH5a6MsVByLHP2ZLQ8gT8jg0) - gpt-4.1-nano
+"""
+
+import os
+import json
+import time
+import logging
+from datetime import datetime
+from typing import Dict, Optional, Any
+
+from openai import OpenAI
+from dotenv import load_dotenv
+
+load_dotenv()
+
+logger = logging.getLogger(__name__)
+
+# ==============================================
+# OPENAI CLIENT & ASSISTANT CONFIGURATION
+# ==============================================
+
+class SimpleOrchestrator:
+    """
+    Vereinfachter Orchestrator f√ºr direkte OpenAI Assistant Integration
+    
+    Features:
+    - Direkte Tool-Call-Unterst√ºtzung
+    - Vereinfachter 3-Schritt-Workflow
+    - SocketIO Integration
+    - Automatische Qualit√§tspr√ºfung
+    """
+    
+    # Assistant Configuration (as specified)
+    ASSISTANTS = {
+        'supervisor': {
+            'id': 'asst_19FlW2QtTAIb7Z96f3ukfSre',
+            'name': 'Supervisor', 
+            'model': 'gpt-4.1-nano'
+        },
+        'content_creator': {
+            'id': 'asst_UCpHRYdDK2uPsb7no8Zw5Z0p',
+            'name': 'Der Autor',
+            'model': 'gpt-4.1-nano'
+        },
+        'didactic_expert': {
+            'id': 'asst_tmj7Nz75MSwjPSrBf4KV2EIt', 
+            'name': 'Der P√§dagoge',
+            'model': 'gpt-4.1-nano'
+        },
+        'quality_checker': {
+            'id': 'asst_qH5a6MsVByLHP2ZLQ8gT8jg0',
+            'name': 'Der Pr√ºfer',
+            'model': 'gpt-4.1-nano'
+        }
+    }
+    
+    def __init__(self, project_id: str, session_id: str, socketio):
+        self.project_id = project_id
+        self.session_id = session_id
+        self.socketio = socketio
+        self.client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))
+        
+        self.thread = None
+        self.current_run = None
+        self.is_processing = False
+        
+        # Load supervisor assistant
+        self.supervisor_assistant = None
+        self._load_supervisor()
+    
+    def _load_supervisor(self):
+        """Load and configure supervisor assistant"""
+        try:
+            supervisor_config = self.ASSISTANTS['supervisor']
+            self.supervisor_assistant = self.client.beta.assistants.retrieve(supervisor_config['id'])
+            
+            # Update tools to ensure they're current
+            required_tools = self._get_required_tools()
+            
+            self.supervisor_assistant = self.client.beta.assistants.update(
+                assistant_id=supervisor_config['id'],
+                tools=required_tools
+            )
+            
+            self.emit_status(f"‚úÖ Supervisor loaded: {supervisor_config['name']}")
+            logger.info(f"Supervisor assistant loaded: {supervisor_config['id']}")
+            
+        except Exception as e:
+            self.emit_error(f"‚ùå Failed to load supervisor: {e}")
+            logger.error(f"Supervisor loading error: {e}")
+    
+    def _get_required_tools(self):
+        """Define required tools for supervisor"""
+        return [
+            {
+                "type": "function",
+                "function": {
+                    "name": "create_content",
+                    "description": "Erstellt einen ersten Rohentwurf f√ºr ein gegebenes Thema mit Content Creator Agent.",
+                    "parameters": {
+                        "type": "object",
+                        "properties": {
+                            "topic": {
+                                "type": "string",
+                                "description": "Das Thema, zu dem der Inhalt erstellt werden soll."
+                            },
+                            "instructions": {
+                                "type": "string",
+                                "description": "Spezifische Anweisungen f√ºr die Inhaltserstellung."
+                            },
+                            "content_type": {
+                                "type": "string",
+                                "description": "Der Typ des zu erstellenden Inhalts: 'outline' f√ºr Inhaltsverzeichnis oder 'full_content' f√ºr vollst√§ndigen Inhalt.",
+                                "enum": ["outline", "full_content"]
+                            }
+                        },
+                        "required": ["topic", "instructions", "content_type"]
+                    }
+                }
+            },
+            {
+                "type": "function",
+                "function": {
+                    "name": "optimize_didactics",
+                    "description": "Optimiert vorhandenen Inhalt didaktisch mit Didactic Expert Agent.",
+                    "parameters": {
+                        "type": "object",
+                        "properties": {
+                            "content": {
+                                "type": "string",
+                                "description": "Der zu optimierende Inhalt."
+                            }
+                        },
+                        "required": ["content"]
+                    }
+                }
+            },
+            {
+                "type": "function",
+                "function": {
+                    "name": "critically_review",
+                    "description": "Pr√ºft Inhalt kritisch auf Logik, Fakten und Konsistenz mit Quality Checker Agent.",
+                    "parameters": {
+                        "type": "object",
+                        "properties": {
+                            "content": {
+                                "type": "string",
+                                "description": "Der zu pr√ºfende Inhalt."
+                            },
+                            "review_type": {
+                                "type": "string",
+                                "description": "Der Typ der Pr√ºfung: 'outline' f√ºr Inhaltsverzeichnis-Review oder 'full_content' f√ºr vollst√§ndige Inhaltspr√ºfung.",
+                                "enum": ["outline", "full_content"]
+                            }
+                        },
+                        "required": ["content", "review_type"]
+                    }
+                }
+            },
+            {
+                "type": "function",
+                "function": {
+                    "name": "request_outline_approval",
+                    "description": "Zeigt dem User das gepr√ºfte Inhaltsverzeichnis und fragt nach Freigabe f√ºr die Volltext-Erstellung. User kann √Ñnderungen vorschlagen.",
+                    "parameters": {
+                        "type": "object",
+                        "properties": {
+                            "outline": {
+                                "type": "string",
+                                "description": "Das detaillierte Inhaltsverzeichnis mit Kapiteln, Lernzielen und groben Beschreibungen."
+                            },
+                            "quality_feedback": {
+                                "type": "string",
+                                "description": "Das Feedback vom Quality Checker zum Outline."
+                            },
+                            "topic": {
+                                "type": "string",
+                                "description": "Das Kursthema."
+                            }
+                        },
+                        "required": ["outline", "quality_feedback", "topic"]
+                    }
+                }
+            },
+            {
+                "type": "function",
+                "function": {
+                    "name": "request_user_feedback",
+                    "description": "Fordert finales Feedback vom User f√ºr den vollst√§ndig erstellten Kursinhalt.",
+                    "parameters": {
+                        "type": "object",
+                        "properties": {
+                            "content": {
+                                "type": "string",
+                                "description": "Der finale Kursinhalt f√ºr den Feedback ben√∂tigt wird."
+                            },
+                            "question": {
+                                "type": "string",
+                                "description": "Die spezifische Frage an den User."
+                            },
+                            "stage": {
+                                "type": "string",
+                                "description": "Das Stadium des Workflows (z.B. 'final_approval')."
+                            }
+                        },
+                        "required": ["content", "question", "stage"]
+                    }
+                }
+            },
+            {
+                "type": "function",
+                "function": {
+                    "name": "knowledge_lookup",
+                    "description": "Durchsucht die projektspezifische Wissensbasis nach relevanten Informationen.",
+                    "parameters": {
+                        "type": "object",
+                        "properties": {
+                            "query": {
+                                "type": "string",
+                                "description": "Die Suchanfrage f√ºr die Wissensbasis."
+                            },
+                            "context": {
+                                "type": "string",
+                                "description": "Zus√§tzlicher Kontext f√ºr die Suche."
+                            }
+                        },
+                        "required": ["query"]
+                    }
+                }
+            }
+        ]
+    
+    def process_message(self, message: str, user_data: Dict):
+        """Main method to process user messages"""
+        if self.is_processing:
+            self.emit_message("‚è≥ Ein anderer Prozess l√§uft bereits. Bitte warten Sie.", "assistant")
+            return
+        
+        if not self.supervisor_assistant:
+            self.emit_error("‚ùå Supervisor assistant not available")
+            return
+        
+        self.is_processing = True
+        self.emit_status("ü§ñ AI-Agent arbeitet...")
+        
+        try:
+            # Create thread if needed
+            if not self.thread:
+                self.thread = self.client.beta.threads.create()
+                self.emit_status("‚úÖ Neuer Thread erstellt")
+            
+            # Add message to thread
+            self.client.beta.threads.messages.create(
+                thread_id=self.thread.id,
+                role="user",
+                content=message
+            )
+            
+            # Start run
+            self.current_run = self.client.beta.threads.runs.create(
+                thread_id=self.thread.id,
+                assistant_id=self.supervisor_assistant.id
+            )
+            
+            # Monitor run
+            self._monitor_run()
+            
+        except Exception as e:
+            self.emit_error(f"‚ùå Processing error: {e}")
+            logger.error(f"Message processing error: {e}")
+        finally:
+            self.is_processing = False
+    
+    def _monitor_run(self):
+        """Monitor run status and handle tool calls"""
+        max_iterations = 50
+        iteration = 0
+        
+        while iteration < max_iterations:
+            try:
+                run = self.client.beta.threads.runs.retrieve(
+                    thread_id=self.thread.id,
+                    run_id=self.current_run.id
+                )
+                
+                if run.status == "completed":
+                    # Get final response
+                    messages = self.client.beta.threads.messages.list(
+                        thread_id=self.thread.id,
+                        limit=1
+                    )
+                    
+                    if messages.data and messages.data[0].content:
+                        response = messages.data[0].content[0].text.value
+                        self.emit_message(response, "assistant")
+                    break
+                    
+                elif run.status == "requires_action":
+                    # Handle tool calls
+                    self._handle_tool_calls(run)
+                    continue
+                    
+                elif run.status in ["failed", "cancelled", "expired"]:
+                    self.emit_error(f"‚ùå Run failed: {run.status}")
+                    break
+                    
+                elif run.status in ["queued", "in_progress"]:
+                    self.emit_status(f"‚è≥ Processing... ({run.status})")
+                
+                time.sleep(2)
+                iteration += 1
+                
+            except Exception as e:
+                self.emit_error(f"‚ùå Monitoring error: {e}")
+                break
+        
+        if iteration >= max_iterations:
+            self.emit_error("‚è∞ Processing timeout")
+    
+    def _handle_tool_calls(self, run):
+        """Handle tool calls from supervisor"""
+        tool_outputs = []
+        
+        for tool_call in run.required_action.submit_tool_outputs.tool_calls:
+            function_name = tool_call.function.name
+            arguments = json.loads(tool_call.function.arguments)
+            
+            self.emit_status(f"üîß Executing {function_name}...")
+            
+            try:
+                if function_name == "create_content":
+                    result = self._call_content_creator(arguments)
+                elif function_name == "optimize_didactics":
+                    result = self._call_didactic_expert(arguments)
+                elif function_name == "critically_review":
+                    result = self._call_quality_checker(arguments)
+                elif function_name == "request_outline_approval":
+                    result = self._request_outline_approval(arguments)
+                elif function_name == "request_user_feedback":
+                    result = self._request_user_feedback(arguments)
+                elif function_name == "knowledge_lookup":
+                    result = self._knowledge_lookup(arguments)
+                else:
+                    result = f"‚ùå Unknown function: {function_name}"
+                
+                # Limit output size
+                if len(str(result)) > 4000:
+                    result = str(result)[:4000] + "... [Content truncated]"
+                
+                tool_outputs.append({
+                    "tool_call_id": tool_call.id,
+                    "output": str(result)
+                })
+                
+                self.emit_status(f"‚úÖ {function_name} completed")
+                
+            except Exception as e:
+                error_msg = f"Error in {function_name}: {str(e)}"
+                self.emit_error(error_msg)
+                
+                tool_outputs.append({
+                    "tool_call_id": tool_call.id,
+                    "output": error_msg
+                })
+        
+        # Submit tool outputs
+        try:
+            self.client.beta.threads.runs.submit_tool_outputs(
+                thread_id=self.thread.id,
+                run_id=run.id,
+                tool_outputs=tool_outputs
+            )
+        except Exception as e:
+            self.emit_error(f"‚ùå Tool output submission error: {e}")
+    
+    def _call_content_creator(self, arguments):
+        """Call content creator assistant"""
+        assistant_config = self.ASSISTANTS['content_creator']
+        topic = arguments.get('topic', '')
+        instructions = arguments.get('instructions', '')
+        content_type = arguments.get('content_type', 'full_content')
+        
+        self.emit_status(f"üñäÔ∏è {assistant_config['name']} erstellt Inhalte...")
+        
+        # Check for knowledge base first
+        try:
+            knowledge_result = self._knowledge_lookup({'query': topic})
+            knowledge_context = f"\n\nVerf√ºgbare Wissensbasis:\n{knowledge_result}" if "Keine relevanten" not in knowledge_result else ""
+        except:
+            knowledge_context = ""
+        
+        prompt = f"""Thema: {topic}
+Anweisungen: {instructions}
+Content-Typ: {content_type}
+{knowledge_context}
+
+Erstelle professionellen Kursinhalt basierend auf diesen Anforderungen."""
+        
+        return self._call_assistant(assistant_config['id'], prompt)
+    
+    def _call_didactic_expert(self, arguments):
+        """Call didactic expert assistant"""
+        assistant_config = self.ASSISTANTS['didactic_expert']
+        content = arguments.get('content', '')
+        
+        self.emit_status(f"üéì {assistant_config['name']} optimiert didaktisch...")
+        
+        prompt = f"""Zu optimierender Kursinhalt:
+
+{content}
+
+F√ºhre eine vollst√§ndige didaktische Optimierung durch."""
+        
+        return self._call_assistant(assistant_config['id'], prompt)
+    
+    def _call_quality_checker(self, arguments):
+        """Call quality checker assistant"""
+        assistant_config = self.ASSISTANTS['quality_checker']
+        content = arguments.get('content', '')
+        review_type = arguments.get('review_type', 'full_content')
+        
+        self.emit_status(f"üîç {assistant_config['name']} pr√ºft Qualit√§t...")
+        
+        prompt = f"""Zu pr√ºfender Inhalt ({review_type}):
+
+{content}
+
+F√ºhre eine kritische Qualit√§tspr√ºfung durch und gib das Ergebnis im JSON-Format aus."""
+        
+        result = self._call_assistant(assistant_config['id'], prompt)
+        
+        # Try to extract quality score for status update
+        try:
+            if '{' in result and '}' in result:
+                json_start = result.find('{')
+                json_end = result.rfind('}') + 1
+                quality_data = json.loads(result[json_start:json_end])
+                
+                overall_score = quality_data.get('scores', {}).get('overall_weighted', 0)
+                if overall_score >= 7.0:
+                    self.emit_status(f"‚úÖ Quality Score: {overall_score}/10 - Qualit√§tsziel erreicht")
+                else:
+                    self.emit_status(f"‚ö†Ô∏è Quality Score: {overall_score}/10 - Verbesserung empfohlen")
+        except:
+            pass
+        
+        return result
+    
+    def _call_assistant(self, assistant_id: str, prompt: str):
+        """Generic method to call any assistant"""
+        try:
+            response = self.client.chat.completions.create(
+                model="gpt-4",  # Fallback model if specific model not available
+                messages=[
+                    {"role": "user", "content": prompt}
+                ],
+                temperature=0.7,
+                max_tokens=4000
+            )
+            
+            return response.choices[0].message.content
+            
+        except Exception as e:
+            logger.error(f"Assistant call error for {assistant_id}: {e}")
+            return f"Assistant {assistant_id} is currently unavailable. Error: {str(e)}"
+    
+    def _request_outline_approval(self, arguments):
+        """Request outline approval from user"""
+        outline = arguments.get('outline', '')
+        quality_feedback = arguments.get('quality_feedback', '')
+        topic = arguments.get('topic', '')
+        
+        approval_msg = f"""## üìã Inhaltsverzeichnis zur Freigabe
+
+**Thema:** {topic}
+
+**Vorgeschlagene Gliederung:**
+{outline}
+
+**Qualit√§tsbewertung:**
+{quality_feedback}
+
+---
+**Bitte best√§tigen Sie die Freigabe oder schlagen Sie √Ñnderungen vor.**"""
+        
+        self.emit_message(approval_msg, "system")
+        return "Warte auf User-Freigabe f√ºr das Inhaltsverzeichnis..."
+    
+    def _request_user_feedback(self, arguments):
+        """Request user feedback"""
+        content = arguments.get('content', '')
+        question = arguments.get('question', '')
+        stage = arguments.get('stage', '')
+        
+        feedback_msg = f"""## üéØ Ihr Feedback ist gefragt!
+
+**Stadium:** {stage}
+**Frage:** {question}
+
+**Erstellter Kurs:**
+{content[:1000]}{'...' if len(content) > 1000 else ''}
+
+---
+**Bitte geben Sie Ihr Feedback oder best√§tigen Sie die Freigabe.**"""
+        
+        self.emit_message(feedback_msg, "system")
+        return "Warte auf User-Feedback..."
+    
+    def _knowledge_lookup(self, arguments):
+        """Search knowledge base"""
+        query = arguments.get('query', '')
+        
+        try:
+            from knowledge_manager import knowledge_lookup
+            result = knowledge_lookup(query, self.project_id)
+            return result
+        except Exception as e:
+            logger.warning(f"Knowledge lookup error: {e}")
+            return f"Wissensbasis f√ºr '{query}' ist momentan nicht verf√ºgbar."
+    
+    # SocketIO Helper Methods
+    def emit_message(self, message, sender="assistant"):
+        """Send message to chat"""
+        room = f'session_{self.session_id}'
+        self.socketio.emit('new_message', {
+            'sender': 'AI-Assistant' if sender == 'assistant' else sender,
+            'message': message,
+            'timestamp': datetime.now().strftime('%H:%M:%S'),
+            'type': sender
+        }, room=room)
+    
+    def emit_status(self, status):
+        """Send status update"""
+        room = f'session_{self.session_id}'
+        self.socketio.emit('status_update', {
+            'status': status,
+            'timestamp': datetime.now().strftime('%H:%M:%S')
+        }, room=room)
+    
+    def emit_error(self, error):
+        """Send error message"""
+        room = f'session_{self.session_id}'
+        self.socketio.emit('error_message', {
+            'error': error,
+            'timestamp': datetime.now().strftime('%H:%M:%S')
+        }, room=room)
+
+# ==============================================
+# ORCHESTRATOR MANAGEMENT
+# ==============================================
+
+# Global orchestrator instances
+active_orchestrators: Dict[str, SimpleOrchestrator] = {}
+
+def get_or_create_orchestrator(project_id: str, session_id: str, socketio) -> SimpleOrchestrator:
+    """Get or create orchestrator instance"""
+    orchestrator_key = f"{project_id}_{session_id}"
+    
+    if orchestrator_key not in active_orchestrators:
+        orchestrator = SimpleOrchestrator(
+            project_id=project_id,
+            session_id=session_id,
+            socketio=socketio
+        )
+        active_orchestrators[orchestrator_key] = orchestrator
+        logger.info(f"Created new orchestrator: {orchestrator_key}")
+    
+    return active_orchestrators[orchestrator_key]
+
+def cleanup_inactive_orchestrators():
+    """Clean up inactive orchestrators (for memory management)"""
+    # Simple cleanup - can be enhanced with TTL logic
+    if len(active_orchestrators) > 10:
+        # Remove oldest orchestrators
+        keys_to_remove = list(active_orchestrators.keys())[:5]
+        for key in keys_to_remove:
+            del active_orchestrators[key]
+        logger.info(f"Cleaned up {len(keys_to_remove)} orchestrators")
\ No newline at end of file
diff --git a/start.py b/start.py
new file mode 100644
index 0000000..02e9022
--- /dev/null
+++ b/start.py
@@ -0,0 +1,60 @@
+"""
+Railway Start Script f√ºr Kiki Chat
+Initialisiert die Datenbank und startet die Anwendung
+"""
+
+import os
+import logging
+from app_simplified import app, db, init_database
+
+# Configure logging for Railway
+logging.basicConfig(
+    level=logging.INFO,
+    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
+)
+logger = logging.getLogger(__name__)
+
+def main():
+    """Main startup function for Railway"""
+    logger.info("Starting Kiki Chat application...")
+    
+    # Initialize database
+    try:
+        with app.app_context():
+            logger.info("Initializing database...")
+            db.create_all()
+            logger.info("‚úÖ Database initialized successfully")
+            
+            # Create default users if they don't exist
+            from app_simplified import User
+            from werkzeug.security import generate_password_hash
+            
+            if not User.query.filter_by(username='admin').first():
+                admin_user = User(
+                    username='admin',
+                    password_hash=generate_password_hash('admin123'),
+                    role='admin'
+                )
+                db.session.add(admin_user)
+                logger.info("Created admin user")
+                
+            if not User.query.filter_by(username='demo').first():
+                demo_user = User(
+                    username='demo',
+                    password_hash=generate_password_hash('demo123'),
+                    role='user'
+                )
+                db.session.add(demo_user)
+                logger.info("Created demo user")
+            
+            db.session.commit()
+            logger.info("‚úÖ Default users created")
+            
+    except Exception as e:
+        logger.error(f"Database initialization error: {e}")
+        # Don't exit - let Railway handle restarts
+    
+    logger.info("‚úÖ Kiki Chat is ready!")
+
+if __name__ == '__main__':
+    main()
\ No newline at end of file
diff --git a/templates/chat_simple.html b/templates/chat_simple.html
new file mode 100644
index 0000000..a6992e9
--- /dev/null
+++ b/templates/chat_simple.html
@@ -0,0 +1,319 @@
+<!DOCTYPE html>
+<html lang="de">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Kiki Chat - KI-Kursstudio</title>
+    
+    <!-- Bootstrap CSS -->
+    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
+    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
+    
+    <!-- Socket.IO -->
+    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
+    
+    <style>
+        .chat-container { height: 80vh; }
+        .messages-container { 
+            height: 60vh; 
+            overflow-y: auto; 
+            border: 1px solid #ddd; 
+            padding: 1rem;
+            background-color: #f8f9fa;
+        }
+        .message {
+            margin-bottom: 1rem;
+            padding: 0.75rem;
+            border-radius: 0.5rem;
+        }
+        .message.user {
+            background-color: #007bff;
+            color: white;
+            margin-left: 20%;
+        }
+        .message.assistant {
+            background-color: white;
+            border: 1px solid #ddd;
+            margin-right: 20%;
+        }
+        .message.system {
+            background-color: #fff3cd;
+            border: 1px solid #ffeaa7;
+            margin: 0 10%;
+        }
+        .typing-indicator {
+            font-style: italic;
+            color: #6c757d;
+        }
+        .status-bar {
+            background-color: #e9ecef;
+            padding: 0.5rem;
+            font-size: 0.875rem;
+            color: #6c757d;
+        }
+    </style>
+</head>
+<body>
+    <div class="container-fluid">
+        <div class="row">
+            <div class="col-12">
+                <!-- Header -->
+                <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
+                    <div class="container-fluid">
+                        <span class="navbar-brand">
+                            <i class="fas fa-robot me-2"></i>Kiki Chat - KI-Kursstudio
+                        </span>
+                        <span class="navbar-text">
+                            Session: {{ session_id }}
+                        </span>
+                    </div>
+                </nav>
+
+                <!-- Status Bar -->
+                <div class="status-bar" id="statusBar">
+                    Bereit f√ºr Ihre Kursanfrage...
+                </div>
+
+                <!-- Main Chat Area -->
+                <div class="chat-container mt-3">
+                    <!-- Messages -->
+                    <div class="messages-container" id="messagesContainer">
+                        <div class="text-center text-muted py-4">
+                            <i class="fas fa-graduation-cap fa-3x mb-3"></i>
+                            <h5>Willkommen im KI-Kursstudio!</h5>
+                            <p>Beschreiben Sie Ihre Kursidee und lassen Sie die KI f√ºr Sie arbeiten.</p>
+                            
+                            <!-- Quick Start Buttons -->
+                            <div class="mt-3">
+                                <button class="btn btn-outline-primary btn-sm me-2 quick-prompt" 
+                                        data-prompt="Erstelle einen Kurs √ºber Python Grundlagen">
+                                    Python Grundlagen
+                                </button>
+                                <button class="btn btn-outline-primary btn-sm me-2 quick-prompt" 
+                                        data-prompt="Ich brauche einen Kurs √ºber digitales Marketing">
+                                    Digitales Marketing
+                                </button>
+                                <button class="btn btn-outline-primary btn-sm quick-prompt" 
+                                        data-prompt="Entwickle einen Kurs √ºber Zeitmanagement">
+                                    Zeitmanagement
+                                </button>
+                            </div>
+                        </div>
+                    </div>
+
+                    <!-- Input Area -->
+                    <div class="row mt-3">
+                        <div class="col-12">
+                            <form id="messageForm" class="d-flex gap-2">
+                                <div class="flex-grow-1">
+                                    <div class="input-group">
+                                        <textarea class="form-control" id="messageInput" 
+                                                 placeholder="Beschreiben Sie Ihre Kursidee..." 
+                                                 rows="3" style="resize: none;"></textarea>
+                                        <button class="btn btn-outline-secondary" type="button" id="fileUploadBtn">
+                                            <i class="fas fa-paperclip"></i>
+                                        </button>
+                                    </div>
+                                </div>
+                                <button type="submit" class="btn btn-primary btn-lg" id="sendBtn">
+                                    <i class="fas fa-paper-plane"></i>
+                                </button>
+                            </form>
+
+                            <!-- File Upload (Hidden) -->
+                            <input type="file" id="fileInput" accept=".pdf,.txt,.docx" style="display: none;">
+
+                            <!-- Typing Indicator -->
+                            <div id="typingIndicator" class="mt-2 typing-indicator" style="display: none;">
+                                <i class="fas fa-circle-notch fa-spin me-1"></i>KI-Agent arbeitet...
+                            </div>
+                        </div>
+                    </div>
+                </div>
+            </div>
+        </div>
+    </div>
+
+    <!-- Bootstrap JS -->
+    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
+
+    <script>
+        // Global variables
+        const SESSION_ID = "{{ session_id }}";
+        const PROJECT_ID = "{{ project_id }}";
+        let socket;
+
+        // Initialize on page load
+        document.addEventListener('DOMContentLoaded', function() {
+            initializeSocketIO();
+            setupEventListeners();
+        });
+
+        function initializeSocketIO() {
+            socket = io();
+
+            socket.on('connect', function() {
+                console.log('Connected to server');
+                socket.emit('join_project', {
+                    session_id: SESSION_ID,
+                    project_id: PROJECT_ID
+                });
+                updateStatus('Verbunden mit Server');
+            });
+
+            socket.on('disconnect', function() {
+                console.log('Disconnected from server');
+                updateStatus('Verbindung unterbrochen');
+            });
+
+            socket.on('new_message', function(data) {
+                addMessage(data.message, data.type, data.sender);
+                hideTypingIndicator();
+            });
+
+            socket.on('status_update', function(data) {
+                updateStatus(data.status);
+            });
+
+            socket.on('error_message', function(data) {
+                updateStatus('‚ùå ' + data.error);
+                hideTypingIndicator();
+            });
+        }
+
+        function setupEventListeners() {
+            // Message form
+            document.getElementById('messageForm').addEventListener('submit', function(e) {
+                e.preventDefault();
+                sendMessage();
+            });
+
+            // Enter key to send (Ctrl+Enter for new line)
+            document.getElementById('messageInput').addEventListener('keydown', function(e) {
+                if (e.key === 'Enter' && !e.ctrlKey && !e.shiftKey) {
+                    e.preventDefault();
+                    sendMessage();
+                }
+            });
+
+            // Quick prompts
+            document.querySelectorAll('.quick-prompt').forEach(btn => {
+                btn.addEventListener('click', function() {
+                    const prompt = this.getAttribute('data-prompt');
+                    document.getElementById('messageInput').value = prompt;
+                    sendMessage();
+                });
+            });
+
+            // File upload
+            document.getElementById('fileUploadBtn').addEventListener('click', function() {
+                document.getElementById('fileInput').click();
+            });
+
+            document.getElementById('fileInput').addEventListener('change', function() {
+                if (this.files.length > 0) {
+                    uploadFiles(this.files);
+                }
+            });
+        }
+
+        function sendMessage() {
+            const messageInput = document.getElementById('messageInput');
+            const message = messageInput.value.trim();
+
+            if (!message) return;
+
+            // Add user message to chat
+            addMessage(message, 'user', 'Sie');
+
+            // Show typing indicator
+            showTypingIndicator();
+
+            // Send to server
+            socket.emit('user_message', {
+                message: message,
+                session_id: SESSION_ID,
+                project_id: PROJECT_ID
+            });
+
+            // Clear input
+            messageInput.value = '';
+        }
+
+        function addMessage(content, type, sender) {
+            const messagesContainer = document.getElementById('messagesContainer');
+            
+            // Remove welcome message if it exists
+            const welcomeMsg = messagesContainer.querySelector('.text-center');
+            if (welcomeMsg) {
+                welcomeMsg.remove();
+            }
+
+            const messageDiv = document.createElement('div');
+            messageDiv.className = `message ${type}`;
+            
+            const timestamp = new Date().toLocaleTimeString('de-DE', {
+                hour: '2-digit',
+                minute: '2-digit'
+            });
+
+            // Format content for better display
+            let formattedContent = content.replace(/\n/g, '<br>');
+            
+            // Convert markdown-like formatting
+            formattedContent = formattedContent.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
+            formattedContent = formattedContent.replace(/\*(.*?)\*/g, '<em>$1</em>');
+
+            messageDiv.innerHTML = `
+                <div class="d-flex justify-content-between align-items-start mb-1">
+                    <small class="fw-bold">${sender}</small>
+                    <small class="text-muted">${timestamp}</small>
+                </div>
+                <div>${formattedContent}</div>
+            `;
+
+            messagesContainer.appendChild(messageDiv);
+            messagesContainer.scrollTop = messagesContainer.scrollHeight;
+        }
+
+        function showTypingIndicator() {
+            document.getElementById('typingIndicator').style.display = 'block';
+        }
+
+        function hideTypingIndicator() {
+            document.getElementById('typingIndicator').style.display = 'none';
+        }
+
+        function updateStatus(status) {
+            document.getElementById('statusBar').textContent = status;
+        }
+
+        function uploadFiles(files) {
+            const formData = new FormData();
+            formData.append('project_id', PROJECT_ID);
+            formData.append('file', files[0]); // Upload first file only for simplicity
+
+            updateStatus('üì§ Datei wird hochgeladen...');
+
+            fetch('/upload-file', {
+                method: 'POST',
+                body: formData
+            })
+            .then(response => response.json())
+            .then(data => {
+                if (data.success) {
+                    updateStatus('‚úÖ Datei erfolgreich hochgeladen');
+                    addMessage(`Datei "${data.details.filename}" wurde hochgeladen und verarbeitet (${data.details.chunks_count} Textabschnitte).`, 'system', 'System');
+                } else {
+                    updateStatus('‚ùå Datei-Upload fehlgeschlagen');
+                    addMessage(`Upload-Fehler: ${data.error}`, 'system', 'System');
+                }
+            })
+            .catch(error => {
+                updateStatus('‚ùå Upload-Fehler');
+                addMessage(`Upload-Fehler: ${error.message}`, 'system', 'System');
+            });
+        }
+    </script>
+</body>
+</html>
\ No newline at end of file
-- 
2.39.5 (Apple Git-154)

